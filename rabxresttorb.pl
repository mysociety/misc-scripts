#!/usr/bin/perl -w -I ../perllib/
#
# rabxresttorb.pl:
# Reads perldoc from a Perl class implementing a RABX interface, and produces a
# Ruby include file for talking to that RABX interface via REST/JSON.
#
# Depends: libpod-pom-perl, libstring-ediff-perl

my $rcsid = ''; $rcsid .= '$Id: rabxresttorb.pl,v 1.2 2010-06-08 13:57:04 louise Exp $';

use strict;

use Pod::POM;
use Data::Dumper;
use Pod::POM::View::Text;

use mySociety::StringUtils qw(trim);

my $perl_source = $ARGV[0];
die "Give source .pm file as first parameter" unless defined($perl_source);

my $parser = Pod::POM->new( { warn => 1} );
my $view = 'Pod::POM::View::Text';

# parse from a text string
my $pom = $parser->parse_file($perl_source) || die $parser->error();

# find items representing functions and display them
my ($rabx_namespace, $rb_namespace, $conf_name);
sub process_functions {
    my $parent = shift;
    foreach my $content ($parent->content()) {
        # print STDERR $content->title() . "\n";
        if ($content->type() eq 'head2' or $content->type() eq 'over') {
            # Recurse through head2 or over
            process_functions($content)
        }  elsif ($content->type() eq 'item') {
            # Display function item as ruby.
            # Find parameters and function name
            my @params = split /\s+/, $content->title();
            my $function_name = shift @params;
            # Print the help comment
            my $comment = $view->view_item($content);
            $comment =~ s/$function_name/${rb_namespace}_$function_name/g;
            chomp $comment;
            chomp $comment;
            $comment = trim($comment);
            # Create list of ruby variables with defaults for optional params
            my $optional = 0;
            my @opt_args;
            my @opt_args_no_default;
            my @call_args;
            do {
                my $param = $_;
                next if $param eq "..."; 
                $optional = 1 if $param =~ m/\[/;
                my $without_punc = $param;
                $without_punc =~ s/[\[\]()]//g;
                push @opt_args, lc($without_punc) . ($optional ? " = nil" : ""); 
                push @opt_args_no_default, lc($without_punc);
                push @call_args, lc($without_punc);
                $optional = 0 if $param =~ m/\]/;
            } foreach @params;
            my $opt_list = join(", ", @opt_args);
            my $opt_list_no_default = join(", ", @opt_args_no_default);
            if ($opt_list_no_default ne '') {
                $opt_list_no_default = ', ' . $opt_list_no_default;
            }
            my $call_list = join(", ", @call_args);
            # Print out ruby function
            print <<END;
def $function_name($opt_list)
=begin 
$comment
=end
  result = do_call_rest_rabx('${rabx_namespace}.${function_name}'$opt_list_no_default)
  return result
end

END
        }
    }
}

sub process_constants {
    my $parent = shift;
    foreach my $content ($parent->content()) {
        if ($content->type() eq 'head2' or $content->type() eq 'over') {
            # Recurse through head2 or over
            process_constants($content)
        } elsif ($content->type() eq 'item') {
            my ($constant, $value) = split /\s+/, $content->title();
            my $comment = $view->view_item($content);
            $comment =~ s/\* $constant $value//gs;
            $comment =~ s/\n/ /g;
            $comment =~ s/\s$//gs;
            $comment =~ s/^\s//gs;
            print "$constant = $value        # $comment\n";
        }
    }
}


# find info
my $description;
foreach my $head1 ($pom->head1()) {
    if ($head1->title() eq "DESCRIPTION") {
        $description = trim($view->view_text($head1));
        $description =~ s/Implementation of/Client interface for/;
    }
    if ($head1->title() eq "NAME") {
        $rabx_namespace = trim($view->view_text($head1));
        if ($rabx_namespace eq 'FYR.Queue') {
            $rb_namespace = 'msg';
            $conf_name = 'FYR_QUEUE';
        } else {
            $rb_namespace = lc $rabx_namespace;
            $conf_name = uc $rabx_namespace;
        }
    }
}
die "Need DESCRIPTION section in perldoc" if !$description;
die "Need NAME section in perldoc" if !$rabx_namespace;

# Print header
print <<END;
# THIS FILE WAS AUTOMATICALLY GENERATED BY $0, DO NOT EDIT DIRECTLY
# 
# ${rb_namespace}.rb:
# $description
#
# Copyright (c) 2010 UK Citizens Online Democracy. All rights reserved.
# WWW: http://www.mysociety.org
#
# $rcsid
#

require 'config'
require 'rabx'

def do_call_rest_rabx(*params)
  base_url = MySociety::Config.get("${conf_name}_URL")
  return MySociety::RABX.call_rest_rabx(base_url, params)
end

END

# find the functions
foreach my $head1 ($pom->head1()) {
    if ($head1->title() eq "FUNCTIONS") {
        process_functions($head1);
    } elsif ($head1->title() eq "CONSTANTS") {
        process_constants($head1);
        print "\n";
    }
}

# print footer
print <<END;
END


