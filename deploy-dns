#!/usr/bin/perl -w
#
# deploy-dns:
# Generate appropriate bind configuration from the zones we use.
#
# Copyright (c) 2006 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: deploy-dns,v 1.17 2006-06-15 13:24:53 chris Exp $';

use strict;

package Oops;

use Error;

@Oops::ISA = qw(Error::Simple);

package main;
require 5.8.0;

use FindBin;
use lib "$FindBin::Bin/../perllib";

use Errno;
use Error qw(:try);
use File::Slurp qw(read_file);
use Getopt::Long;
use IO::File;
use mySociety::Util qw(create_file_to_replace describe_waitval);
# we use ::Fast not for speed, but because it works and the regular one
# doesn't.
use Net::DNS::ZoneFile::Fast;
use Pod::Usage;
use Regexp::Common qw(dns);
use Socket;

# These are the nameservers we list.
my @nameservers = qw(
        ns0.ukcod.org.uk
        ns1.ukcod.org.uk
        ns0.flirble.org.uk
        ns1.flirble.org.uk
        ns2.flirble.org.uk
        ns3.flirble.org.uk
        ns4.flirble.org.uk
    );

# JPC email of 20060125
my @notify = qw(
        195.40.6.30
        194.70.3.22
        212.134.5.1
        207.162.195.200
        207.162.200.1
    );

my @allow_xfer = qw(
        194.70.3.10         194.70.3.20         194.70.3.22
        194.70.3.30         194.70.3.50         195.40.6.20
        195.40.6.30         195.40.6.22         207.162.195.200
        208.184.62.12       208.184.62.15       212.134.5.1
        193.131.248.2       193.131.248.24      195.40.0.200
        193.131.248.36      195.40.1.36         195.40.1.38
        195.40.6.65         195.40.0.250        195.40.1.250
        212.135.72.27       195.40.0.250        195.40.1.250
        193.131.248.22      195.40.1.37         207.162.200.1
        212.135.203.110     212.135.203.107     212.71.68.59
        80.202.84.84        194.200.2.229       213.253.1.110
        193.0.0.0/23
    );

my $notify_list = join('; ', @notify) . ';';
my $allow_xfer_list = join('; ', @allow_xfer) . ';';

my $be_verbose = 0;
sub verbose (@) {
    return unless ($be_verbose);
    print STDERR @_;
}

sub System (@) {
    system(@_);
    throw Oops("$_[0]: " . describe_waitval($?, "system"))
        if ($?);
}

sub parse ($) {
    my $text = shift;
    my $R;
    $@ = undef;
    # Behaviour of Net::DNS::ZoneFile::Fast::parse on errors is not documented,
    # but it appears to throw an error which contains a line number.
    eval {
        $R = Net::DNS::ZoneFile::Fast::parse($text);
    };
    if ($@) {
        my $err = $@;
        $err =~ s/\n+.*//s;
        return $err;
    } else {
        return $R;
    }
}

# test_zonefile FILE
# Confirm that the named zone FILE (a) is syntactically valid; and (b) has a
# later serial number than any existing version of the same zonefile, if it
# differs. Throws an Oops on a fatal error, returns a string describing any
# error in FILE, or undef if nothing is wrong.
sub test_zonefile ($) {
    my $file = shift;

    my $newtext = read_file($file) || throw Oops("$file: $!");
    my $f = new IO::File("/var/named/master/$file", O_RDONLY);
    throw Oops("/var/named/master/$file: $!") if (!$f && !$!{ENOENT});
    my $oldtext;
    if ($f) {
        $oldtext = read_file($f) || throw Oops("/var/named/master/$file: $!");
        $f->close();
    }

    verbose("  parsing file... ");
    my $rrset = parse($newtext);
    if (!ref($rrset)) {
        return $rrset;
    } elsif (!@$rrset) {
        return "no RRs in zone file";
    } elsif ($rrset->[0]->type() ne 'SOA') {
        return "first RR should be SOA, not " . $rrset->[0]->type();
    }
    verbose("OK\n");

    # If there's no old file or the file hasn't changed, this is all we need to
    # do.
    return undef if (!$oldtext || $newtext eq $oldtext);

    verbose("  an old version exists; parsing that... ");

    my $newserial = $rrset->[0]->serial();
    $rrset = Net::DNS::ZoneFile::Fast::parse($oldtext);
    if ($rrset && @$rrset && $rrset->[0]->type() eq 'SOA') {
        verbose("OK\n");
        my $oldserial = $rrset->[0]->serial();
        verbose("  old serial = $oldserial; new serial = $newserial\n");
        return "new serial number, '$newserial', is not larger than old serial number, '$oldserial', but the files differ"
            unless ($newserial gt $oldserial);
    } elsif (!defined($rrset)) {
        print STDERR "deploy-dns: WARNING: current $file is syntactically invalid\n";
    } elsif (!@$rrset) {
        print STDERR "deploy-dns: WARNING: current $file contains no RRs\n";
    } else {
        print STDERR "deploy-dns: WARNING: first RR in $file is not SOA\n";
    }
    verbose("  new file is OK\n");

    return undef;
}

#
# Our zonefiles are stored in CVS in servers/dns. There are both zone files and
# .symlink files (as used by deploy-configuration) for configuring several
# domains identically. This script is responsible for checking that each zone
# file in the working directory at /data/servers/dns is valid, for copying them
# into /var/named/master, writing an appropriate /etc/bind/domains.conf and
# restarting the nameserver.
#

my @files_to_delete = ();
my $ret = 1;

try {
    my $help = 0;
    my $check_only = 0;
    if (!GetOptions(
            'help' =>           \$help,
            'verbose' =>        \$be_verbose,
            'check-only' =>     \$check_only
        )) {
        throw Oops("bad options; try --help for help");
    }

    if ($help) {
        pod2usage(-exitval => 0, -verbose => 2);
        exit(0);
    }

    chdir("/data/servers/dns") || throw Oops("/data/servers/dns: $!");

    # Get the list of files under CVS control from CVS/Entries. This is nasty,
    # but the alternatives are worse.
    verbose("getting list of domains...");
    my $f = new IO::File("CVS/Entries", O_RDONLY) || throw Oops("CVS/Entries: $!");

    my %files = ();
    while (defined(my $line = $f->getline())) {
        $files{$1} = 0 if ($line =~ m#^/([^/]+)/# && $1 !~ /^(?:_perm|\.cvsignore)$/);
    }
    throw Oops("CVS/Entries: $!") if ($f->error());
    $f->close();

    verbose("done; found " . scalar(keys(%files)) . " domains");

    my $errors = 0;
    my @domains = ();
    foreach my $n (sort keys %files) {
        my $domain = $n;
        if ($domain =~ /^(.*)\.symlink$/) {
            push(@domains, $1);
            verbose("will symlink $1 to ");
            my $t = read_file($domain) || throw Oops("$domain: $!");
            if ($t !~ /^To:\s*(.*)$/m) {
                print STDERR "deploy-dns: $domain: not a proper .symlink file\n";
                ++$errors;
                next;
            } elsif (!exists($files{$1})) {
                print STDERR "deploy-dns: $domain: symlink to a file which does not exist: $1\n";
                ++$errors;
                next;
            }
            verbose("$1\n");
            $domain = $1;
        } else {
            verbose("will create zone file $domain\n");
            push(@domains, $domain);
            # Force permissions to a+r.
            chmod(0644, $domain);
        }

        if (!$files{$domain}) {
            verbose("testing zone file $domain for validity...\n");
            if (my $err = test_zonefile($domain)) {
                print STDERR "deploy-dns: $domain: $err\n";
                ++$errors;
            } else {
            }
            ++$files{$domain};
        }
    }

    throw Oops("problems with DNS zones") if ($errors > 0);

    if ($check_only) {
        verbose("done, since only checking the zone files\n");
        goto done;
    }

    # In case this is the first time we've been run, create an empty
    # domains.conf.
    verbose("trying to open /var/named/etc/bind/domains.conf... ");
    $f = new IO::File("/var/named/etc/bind/domains.conf", O_WRONLY | O_CREAT, 0644);
    throw Oops("/var/named/etc/bind/domains.conf: $!") if (!$f);
    $f->close();
    verbose("OK\n");

    $@ = undef;
    my ($name, $h);
    verbose("creating file to replace /var/named/etc/bind/domains.conf... ");
    eval {
        ($name, $h) = create_file_to_replace("/var/named/etc/bind/domains.conf");
    };
    throw Oops("unable to create file to replace /var/named/etc/bind/domains.conf: $!") if ($@);
    push(@files_to_delete, $name);
    verbose("done; temporary filename is $name\n");

    $h->print(<<EOF);
/*
 * domains.conf: configuration for domains we host
 *
 * THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT!
 *
 * See /data/servers/dns for the real deal.
 */

acl notify_list { $notify_list };
acl allow_xfer_list { $allow_xfer_list };

EOF

    foreach my $domain (@domains) {
        $h->printf(<<EOF,
zone "%s" {
    type master;
    file "master/%s";
    allow-query { 0.0.0.0/0; };
    allow-transfer { allow_xfer_list; };
};
EOF
            $domain, $domain)
                || throw Oops("$name: $!");
    }

    $h->close() || throw Oops("$name: $!");

    # Now copy the zonefiles themselves. Use deploy-configuration for that.
    # XXX this is broken -- deploy-configuration will also copy files that
    # aren't in CVS, such as editor backup files, etc. Should warn/abort if
    # there are any such before we get to this stage.
    my @cmd = qw(/data/mysociety/bin/deploy-configuration
                --no-check-existing
                --target /var/named/master);
    push(@cmd, "--verbose") if ($be_verbose);
    push(@cmd, qw(/data/servers/dns /dev/null));
    verbose("args to deploy-configuration: ", join(" ", @cmd), "\n");
    verbose("invoking deploy-configuration...\n");
    System(@cmd);
    verbose("  done\n");

    # We win.
    verbose("renaming $name to /var/named/etc/bind/domains.conf... ");
    rename($name, "/var/named/etc/bind/domains.conf")
        || throw Oops("/var/named/etc/bind/domains.conf: $!");
    verbose("done\n");

    # Try to reload the zones, but failure is not a fatal error.
    verbose("telling bind to reload zones... ");
    System(qw(rndc reload));
    verbose("done\n");

    System("/data/mysociety/bin/deploy-logger", "Deployed DNS");

done:
    $ret = 0;

} catch Oops with {
    my $E = shift;
    print STDERR "deploy-dns: ", $E->text(), "\n";
    $ret ||= 1;
} finally {
    foreach (@files_to_delete) {
        unlink($_);
    }
};

exit($ret);

__END__

=head1 NAME

deploy-dns

=head1 SYNOPSIS

deploy-dns --help | [OPTIONS]

=head1 DESCRIPTION

Takes zone files etc. in /data/servers/dns (which should be a CVS checkout),
installs them in /var/named for bind to read, and creates a bind configuration
file to draw the nameserver's attention to them.

=head1 OPTIONS

=over 4

=item --help

Display this help message.

=item --verbose

Print lots of verbose debugging information on standard error.

=item --check-only

Only check that the new zone files are valid; do not install them.

=back

=cut
