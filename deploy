#!/bin/sh
#
# bin/deploy
# Uploading website from CVS to server.
#
# Copyright (c) 2004 UK Citizens Online Democracy. All rights reserved.
# Email: francis@mysociety.org; WWW: http://www.mysociety.org/
#
# $Id: deploy,v 1.7 2004-11-26 15:13:21 francis Exp $
#

set -e

# Fax Your Representative
FYR_VHOST=/data/vhost/notfinished.faxyourrepresentative.com
FYR_NAME="WriteToThem.com"
FYR_UNAME=fyr
FYR_DEPLOYSPACE=$FYR_VHOST/deployspace

# Web services (Ratty, DaDem, MaPit etc.)
SERVICES_VHOST=/data/vhost/services.mysociety.org
SERVICES_UNAME=mysociety
SERVICES_DEPLOYSPACE=$SERVICES_VHOST/deployspace

# Server this script checks it is being run upon
EXPECTED_HOST=very.unfortu.net

# Location of mysociety/bin scripts
MYSOCIETY_BIN=`pwd`

# User to load test schema
PSQL_SCHEMATEST_USER=pgsql

# Main body of script
main () {
    # Currently just FYR and services to update

    cat << END
    This will update services.mysociety and notfinished.faxyourrepresentative.com
    from CVS and gracefully restart Apache.  It will warn you first if
    any database schemas need upgrading, or config files fixing.  These
    get fixed in the deploy space, i.e. the place where the "cvs export"
    happens to, before copying over to the live server.

    Press RETURN to continue.
END
    read DUMMY

    echo "Exporting from CVS..."
    cvs_export $FYR_UNAME $FYR_VHOST $FYR_DEPLOYSPACE
    cvs_export $SERVICES_UNAME $SERVICES_VHOST $SERVICES_DEPLOYSPACE

    echo "Checking config files..."
    check_config_files $FYR_VHOST/mysociety/fyr/conf
    check_config_files $SERVICES_VHOST/mysociety/services/conf

    echo "Checking database schemas..."
    read_conf $FYR_VHOST/mysociety/fyr/conf/general
    check_pgsql_schema $FYR_VHOST/mysociety/fyr/db/schema.sql $OPTION_FYR_QUEUE_DB_NAME $OPTION_FYR_QUEUE_DB_USER $OPTION_FYR_QUEUE_DB_PASS

    read_conf $SERVICES_VHOST/mysociety/services/conf/general
    #check_sqlite_schema $SERVICES_VHOST/mysociety/services/mapit-dadem-loading/mapit-schema.sql $OPTION_MAPIT_SQLITE_DB
    #check_sqlite_schema $SERVICES_VHOST/mysociety/services/mapit-dadem-loading/dadem-schema.sql $OPTION_DADEM_SQLITE_DB
    check_pgsql_schema $SERVICES_VHOST/mysociety/services/Ratty/schema.sql $OPTION_RATTY_DB_NAME $OPTION_RATTY_DB_USER $OPTION_RATTY_DB_PASS

    echo "Stopping services..."
    down_notice $FYR_VHOST $FYR_NAME
    daemon_stop fyrqd

    echo "Rsyncing new data files..."
    rsync_across $FYR_DEPLOYSPACE $FYR_VHOST
    rsync_across $SERVICES_DEPLOYSPACE $SERVICES_VHOST

    echo "Starting services..."
    daemon_start fyrqd
    apachectl graceful
    up_notice $FYR_VHOST
}

# Check we are root@$EXPECTED_HOST
check_who_where () {
    if [ ! -d "../../mysociety/bin" ] 
    then 
        echo "Please run with mysociety/bin as current directory."
        echo "Or fix it up to find the other scripts somehow else :)"
        exit 1
    fi
    if [ "`id -u`" != "0" ]
    then
        echo "Please run as root only"
        exit 1
    fi

    if [ `hostname` != "$EXPECTED_HOST" ]
    then
        echo "Please run on $EXPECTED_HOST only"
        exit 1
    fi
}

# Exports from CVS into the deploy space, erasing whatever was there
# already.  Copies current config files from the vhost. 
# $1 - user name to su to 
# $2 - path to vhost, where live server is
# $3 - path to deploy space, GETS ERASED FIRST
cvs_export () {
    cd $3
    rm -fr mysociety
    export CVSROOT=/usr/local/cvs
    su $1 -c "cvs -Q export -r HEAD -d mysociety mysociety"

    cd $2
    for X in mysociety/*/conf/general 
    do
        cp $X $3/$X
    done
}

# Copies from the deploy space to the live space using rsync.
# $1 - path to deploy space
# $2 - path to vhost, where live server is, GETS OVERWRITTEN BY DEPLOY SPACE
rsync_across () {
    rsync -a $1/mysociety/ $2/mysociety
}

# Marks a vhost as being down for maintenance.
# $1 - path to vhost
# $2 - display name of website
down_notice () {
    cat >$1/docs/.down.html.new <<END
<html>
<head>
<title>$2 - Down for Maintenance</title>
</head>
<body>
<p>Sorry, but $2 is currently not available.  We're doing a spot of
maintenance.  Check back in a few minutes, and everything should be
restored to order.  Thanks for your patience!
<p> &mdash; the <a href="http://www.mysociety.org">mySociety</a> developers
</body>
</html>
END
    mv $1/docs/.down.html.new $1/docs/down.html
}

# Removes the file which displays a vhost as being down for maintenance.
# $1 - path to vhost
up_notice () {
    rm $1/docs/down.html
}

# Stops a daemon
# $1 - name of daemon
daemon_stop () {
    /usr/local/etc/rc.d/$1.sh stop || echo "daemon stop failed, continuing anyway"
}

# Starts a daemon
# $1 - name of daemon
daemon_start () {
    /usr/local/etc/rc.d/$1.sh start
}

# Checks config file has all options
# $1 - path to conf folder with general and general-example in it
check_config_files () {
    cd $MYSOCIETY_BIN
    ./compareconfig.pl $1/general $1/general-example || exit 1
    cd -
}

# Tests if the schema in a file is the same as in a postgra postgresql
# database.
# $1 - schema file
# $2 - pgsql db name
# $3 - pgsql db user
# $4 - pgsql db pass
check_pgsql_schema () {
    CVS_SCHEMA_FILE=`mktemp /tmp/ms-deploy-cvsschema.XXXXXX`
    CURRENT_SCHEMA_FILE=`mktemp /tmp/ms-deploy-currentschema.XXXXXX`

    # load file schema into a temporary place to dump it
    # in the same format as ...
    dropdb -q -U $PSQL_SCHEMATEST_USER schematest || echo "schematest already dropped, continuing"
    createdb -q -U $PSQL_SCHEMATEST_USER schematest
    psql --file=$1 -U $PSQL_SCHEMATEST_USER -q schematest
    pg_dump -s -U $PSQL_SCHEMATEST_USER schematest | egrep -v "^--|SET SESSION AUTHORIZATION|\\connect - " | sort > $CVS_SCHEMA_FILE

    # ... the live database dump
    pg_dump -s -U $3 $4 | egrep -v "^--|SET SESSION AUTHORIZATION|\\connect - " | sort > $CURRENT_SCHEMA_FILE

    # Note:  Using sort in the above is completely evil.  It is because
    # older verions of pg_dump don't output the tables in a stable
    # order.  The above code would get confused it a column was moved
    # from one table to another with no other changes.  Hopefully this
    # is unlikely.  More recent pgsql have a fixed pg_dump.  Or a Perl
    # script could be used to compare schemas.
    # If you hate this send us a patch ;)  Better actually release a
    # comprehensive schema comparing tool...

    # Compare them
    if ! diff $CVS_SCHEMA_FILE $CURRENT_SCHEMA_FILE 
    then
        echo
        echo "Schema in CVS differs from that in pgsql database, you need to update it"
        echo "Database: $2 User:$3 Schema: $1"
        echo 
        exit 1
    fi
}

# $1 - schema file
# $2 - sqlite db file
check_sqlite_schema () {
    CURRENT_SCHEMA_FILE=`mktemp /tmp/ms-deploy-currentschema.XXXXXX`

    # Dump current schema
    sqlite $2 .schema > $CURRENT_SCHEMA_FILE

    # Note: How does sqlite cope schemas altered with "alter table"?
    # This could be a problem.

    # Compare them
    if ! diff $1 $CURRENT_SCHEMA_FILE 
    then
        echo
        echo "Schema in CVS differs from that in sqlite database, you need to update it"
        echo "Database: $2 Schema: $1"
        echo 
        exit 1
    fi
}

# Reads in config file
# Currently doesn't read in numeric values
# $1 - config file
read_conf () {
    CONF_SOURCE=`mktemp /tmp/ms-deploy-configsource.XXXXXX`
    cat $1 | grep define | egrep -v "^\/\/" | sed "s/define('\(.*\)', '\(.*\)'.*/\1=\"\2\"/" | egrep -v "define|mySociety::Config" >$CONF_SOURCE
    . $CONF_SOURCE
}

check_who_where
main

