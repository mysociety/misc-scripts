#!/usr/bin/perl -w
#
# deploy-vhost:
# Deploy a virtual host.
#
# Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
# Email: francis@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: deploy-vhost,v 1.101 2009-10-29 10:08:15 francis Exp $';

package main;

use strict;
require 5.8.0;

use FindBin;
use lib "$FindBin::Bin/../perllib";
my $mysociety_bin = $FindBin::Bin;
my $servers_dir = "$FindBin::Bin/../../servers";
my $mysociety_dir = "$FindBin::Bin/../../mysociety";

use mySociety::SystemMisc qw(shell);
use mySociety::Config;

use Cwd;
use POSIX qw(getuid);
use Data::Dumper;
use File::Slurp;
use File::Copy;
use File::Temp qw(tempfile mktemp);

our $verbose = $ENV{VERBOSE} ? 1 : 0;

#####################################################################
# General functions

sub make_dir {
    my $dir = shift;
    if (! -d $dir) {
        mkdir($dir) || die "failed to mkdir '$dir'";
    }
}

sub make_symlink {
    my ($a, $b) = @_;
    my $current = readlink($b);
    if (!$current) {
        symlink($a, $b) || die "failed to make symlink '$b' -> '$a'";
    } elsif ($current ne $a) {
        die "remove existing wrong symlink '$b' -> '$current' first, so can become '$b' -> '$a'";
    }
}

sub pgpw {
    $_ = shift;
    $_ = `/data/mysociety/bin/pgpw $_`;
    s/\s+$//;
    return $_;
}
#####################################################################
# Main code

# Read in configuration file
our ($vhosts, $sites, $databases);
require "$servers_dir/vhosts.pl";

# Check command line parameters, look up in config file
die "Specify virtual host name as first parameter, deploy/stop/update/start/remove as second parameter" if scalar(@ARGV) != 2;
my $vhost = $ARGV[0];
my $vhost_conf = $vhosts->{$vhost};
die "vhost '$vhost' is not in vhosts.pl" if !$vhost_conf;
my $site = $vhost_conf->{'site'};
die "site not specified for '$vhost' in vhosts.pl" if !$site;
my $site_conf = $sites->{$site};
die "site '$site' is not in vhosts.pl" if !$site_conf;
my $vhost_dir = "/data/vhost/$vhost";
my $action = $ARGV[1];
die "Specify 'deploy', 'stop', 'update', 'start' or 'remove' as second parameter" if $action ne "deploy" && $action ne "stop" && $action ne "update" && $action ne "start" && $action ne 'remove';

# Merge vhost and site configs together
my $conf;
foreach my $key ( keys %$site_conf ) { $conf->{$key} = $site_conf->{$key}; }
foreach my $key ( keys %$vhost_conf ) { $conf->{$key} = $vhost_conf->{$key}; }
die "must specify 'servers' in vhost config" if (!exists($conf->{servers}));
die "must specify 'staging' in vhost config" if (!exists($conf->{staging}));
die "must specify one of 'cvs_dirs' or 'git_repository' in vhost config" if (!exists($conf->{cvs_dirs}) && !exists($conf->{git_repository}) );
die "must specify 'cvs_dirs' or 'git_repository' (not both) in vhost config" if (exists($conf->{cvs_dirs}) && exists($conf->{git_repository}) );
my $vcspath;
my $cvs = 0;
my $git = 0;
if (exists($conf->{cvs_dirs})) {
    die "must specify 'cvs_user' in vhost config" if (!exists($conf->{cvs_user}));
    $vcspath = "mysociety";
    $cvs = 1;
}
if (exists($conf->{git_repository})) {
    die "must specify 'git_user' in vhost config" if (!exists($conf->{git_user}));
    $vcspath = $conf->{git_repository};
    $git = 1;
}

# Verify that this server is listed for this vhost
my $hostname = `hostname`;
chomp($hostname);
die "'$hostname' is not a vhost for '$vhost'" if !grep { m/^$hostname$/ } @{$conf->{'servers'}};

# Look up some values
my ($user_login, $user_pass, $user_uid, $user_gid, 
    $user_quota, $user_comment, 
    $user_real_name, $user_home_dir, $user_shell,
    $user_expire) = getpwnam($conf->{'user'});
die "Unknown user '".$conf->{'user'}."'" if !$user_uid;
die "Unknown group for user '".$conf->{'user'}."'" if !$user_gid;
my $user = $conf->{'user'};
my $group = getgrgid($user_gid);
$conf->{'wildcard_vhost'} = 0 if (!exists($conf->{'wildcard_vhost'}));
$conf->{'https'} = 0 if (!exists($conf->{'https'}));
$conf->{'fastcgi'} = 1 if (!exists($conf->{'fastcgi'}));

# Ensure that the conf_dir element is a reference to a list of config dirs.
my $c = $conf->{conf_dir};
$c ||= [];
$c = [$c] if (!ref($c));
$conf->{conf_dir} = $c;

#####################################################################
# Make directories and conf files, check database and conf files

# Create directories and symlink to docs
make_dir("/data");
make_dir("/data/vhost");
make_dir("$vhost_dir");
chown($user_uid, $user_gid, "$vhost_dir");
make_dir("$vhost_dir/logs");
chown($user_uid, $user_gid, "$vhost_dir/logs");
make_symlink("$vcspath/".$conf->{'web_dir'}, "$vhost_dir/docs");
shell("chown", "-h", "$user_uid:$user_gid", "$vhost_dir/docs"); # perl's chown doesn't do symlinks

if ($cvs) {
    # Initial checkout, for CVS directories which don't exist
    my $cvsroot;
    if ($conf->{'cvs_user'} eq "") {
        $cvsroot = "cvs.mysociety.org:/usr/local/cvs";
    } elsif ($conf->{'cvs_user'} eq 'anon') {
        $cvsroot = ':pserver:anonymous@cvs.mysociety.org:/repos';
        # for some reason, CVS gives a warning if there is no .cvspass file during 
        # anoncvs client use, so we make an empty file
        if (! -e "$user_home_dir/.cvspass") {
            system("su $conf->{'user'} -c \"touch ~$conf->{'user'}/.cvspass\"");
        }
        # note that anoncvs is now freshly updated automatically by anoncvs-wrapper
    } else {
        $cvsroot = $conf->{'cvs_user'} . "\@cvs.mysociety.org:/usr/local/cvs";
    }
    make_cvs_dirs($cvsroot, $conf->{'cvs_user'}, $conf->{'cvs_dirs'});
    if (exists($conf->{'private_cvs_dirs'})){
        die "must specify 'private_cvs_user' in vhost config" if (!exists($conf->{'private_cvs_user'}));
        my $privatecvsroot = $conf->{'private_cvs_user'} . "\@cvs.mysociety.org:/usr/local/privatecvs";
        make_cvs_dirs($privatecvsroot, $conf->{'private_cvs_user'}, $conf->{'private_cvs_dirs'});
    }
} elsif ($git) {
    # Initial clone, for git repository that don't exist
    my $git_url_base;
    if ($conf->{'git_user'} eq "") {
        $git_url_base = "ssh://git.mysociety.org/data/git/public/";
    } elsif ($conf->{'git_user'} eq 'anon') {
        $git_url_base = "git://git.mysociety.org/"
    } else {
        $git_url_base = "ssh://" . $conf->{'git_user'} . "\@git.mysociety.org/data/git/public/";
    }
    make_git_repository($git_url_base, $conf->{'git_user'}, $conf->{'git_repository'});
} else {
    die "Unknown version control system";
}

# Make public directories
foreach my $public_dir (@{$conf->{'public_dirs'}}) {
    make_dir("$vhost_dir/$public_dir");
    chown($user_uid, $user_gid, "$vhost_dir/$public_dir");
}

# Make database config settings
my $database_configs = "";
my $rails_database_config = "";
if (defined $conf->{'databases'}) {
    foreach my $database (@{$conf->{'databases'}}) {
        my $params = $databases->{$database};
        if ($params->{type} eq 'psql') {
            $database_configs .= <<END;
define('OPTION_$params->{prefix}_DB_HOST', '$params->{host}.int.ukcod.org.uk');
define('OPTION_$params->{prefix}_DB_PORT', $params->{port});
define('OPTION_$params->{prefix}_DB_NAME', '$database');
define('OPTION_$params->{prefix}_DB_USER', '$database');
define('OPTION_$params->{prefix}_DB_PASS', '\${\\(pgpw('$database'))}');
END
            # XXX doesn't cope with multiple Rails database configs (as you
            # have to list them in the yml file in right place, so one text
            # option can't), oh well
            if (scalar(@{$conf->{'databases'}}) == 1) {
                $rails_database_config = <<END;
    adapter: postgresql
    database: $database
    username: $database
    password: \${\\(pgpw('$database'))}
    host: $params->{host}.int.ukcod.org.uk
    port: $params->{port}
END
            }
#define('OPTION_$params->{prefix}_DB_PASS', '!!(*= pgpw('$database') *)!!');
        } elsif ($params->{type} eq 'mysql') {
            $database_configs .= <<END;
define('OPTION_$params->{prefix}_DB_HOST', '$params->{host}.int.ukcod.org.uk');
define('OPTION_$params->{prefix}_DB_NAME', '$database');
define('OPTION_$params->{prefix}_DB_USER', '$database');
define('OPTION_$params->{prefix}_DB_PASS', '\${\\(pgpw('$database'))}');
END
        } else {
            die "unknown database type '$params->{type}'";
        }
    }
}

# Make some settings
$vhost =~ m/^([^.]+)\.(.*)$/;
my $vhost_first = $1;
my $vhost_rest = $2;
# Create settings file
my $settings_file_namepart = "settings-autogen.pl";
my $settings_file = "$vhost_dir/$settings_file_namepart";
my $global_settings_file = "/etc/mysociety/config-settings.pl";
my $global_settings = read_file($global_settings_file) or die "failed to read /etc/mysociety/config-settings.pl, which is made by deploy-configuration";
my $old_umask = umask(0077);
open(FH, "> $settings_file") or die "failed to open $settings_file for write";
print FH <<END;
#
# $settings_file_namepart
#

\$site = '$site';
\$vhost = '$vhost';
\$vcspath = '$vcspath';
\$site = '$site';
\$staging = '$conf->{'staging'}';
\$vhost_first = '$vhost_first';
\$vhost_rest = '$vhost_rest';
\$user = '$user';
\$group = '$group';
\$wildcard_vhost = '$conf->{'wildcard_vhost'}';
\$https = '$conf->{'https'}';
\$fastcgi = '$conf->{'fastcgi'}';
\$randomly = '/data/mysociety/bin/randomly -p 0.5'; # for crontab
\$database_configs = <<DONE_DATABASE_CONFIGS;
$database_configs
DONE_DATABASE_CONFIGS
\$rails_database_config = <<DONE_RAILS_DATABASE_CONFIG;
$rails_database_config
DONE_RAILS_DATABASE_CONFIG
END

print FH Dumper($conf->{conf_dir});
print FH "\$conf_dirs = \$VAR1;\n";
print FH Dumper($conf->{private_conf_dir});
print FH "\$private_conf_dirs = \$VAR1;\n";
print FH "\$admin_dir = '$conf->{'admin_dir'}';\n" if $conf->{'admin_dir'};
print FH "\$admin_group = '$conf->{'admin_group'}';\n" if $conf->{'admin_group'};
die "admin_group must be specified if admin_dir is" if $conf->{'admin_dir'} && !$conf->{'admin_group'};
print FH "\$admin_uri = '$conf->{'admin_uri'}';\n" if $conf->{'admin_uri'};
die "admin_group must be specified if admin_uri is" if $conf->{'admin_uri'} && !$conf->{'admin_group'};
print FH "\$internal_access_only = '$conf->{'internal_access_only'}';\n" if $conf->{'internal_access_only'};
print FH Dumper($conf->{'public_dirs'});
print FH "\$public_dirs = \$VAR1;\n";
print FH Dumper($conf->{'redirects'});
print FH "\$redirects = \$VAR1;\n";
print FH Dumper($conf->{'aliases'});
print FH "\$aliases = \$VAR1;\n";
print FH <<END;

# ---------------------------------------------------------
# Settings from here on are copied from:
# $global_settings_file

$global_settings
END
close FH;
chown($user_uid, $user_gid, $settings_file);
umask($old_umask);

# Generate daemon init scripts from templates
foreach my $daemon (keys %{$conf->{'daemons'}}) {
    # XXX assume daemon is configured from first conf_dir.
    my $daemon_mugly_path = $mysociety_dir . '/' . $conf->{conf_dir}->[0] . '/';
    my $daemon_mugly_file = $conf->{'daemons'}->{$daemon};
    chdir $daemon_mugly_path;
    shell("cvs", "-Q", "update", "$daemon_mugly_file");
    my $daemon_mugly = $daemon_mugly_path . $daemon_mugly_file;
    my ($fh, $filename) = tempfile();
    open(FH, ">$filename") or die "failed to open $filename for write";
    print FH "\$daemon_name = '$daemon';\n";
    close FH;
    shell("$mysociety_bin/mugly", "-O", "/etc/init.d/$daemon", "-p", "$settings_file", "-p", "$filename", "$daemon_mugly");
    unlink($filename);
    chmod 0755, "/etc/init.d/$daemon";
    system("update-rc.d $daemon defaults | grep -v \"System startup links for .* already exist\"");
}

# Create httpd configuration stanza
shell("$mysociety_bin/mugly", "-O", "/etc/apache/virtualhosts.d/$vhost.conf", "-p", "$settings_file", "$servers_dir/vhosts/single-vhost.conf.ugly");

# Work out name of crontab
my $cron_name = "vhost-$vhost";
$cron_name =~ s/\./-/g;
$cron_name = "/etc/cron.d/$cron_name";

if ($action ne "remove"){
    check_packages();
}

#####################################################################
# Helper functions

sub apache_graceful {
    if (-e "/usr/sbin/apache") {
        shell("apachectl", "graceful");
    }
    if (-e "/usr/sbin/apache2") {
        shell("apache2ctl", "graceful");
    }
}

sub make_cvs_dirs {
   my ($cvs_root, $cvs_user, $cvs_dirs) = @_;
   foreach my $cvs_dir (@{$cvs_dirs}) {
       my $d = "$vhost_dir/mysociety/$cvs_dir/CVS";
       if (! -d $d) {
           if ($cvs_user eq "") { 
               shell("cd \"$vhost_dir\" && cvs -Q -d \"$cvs_root\" co mysociety/$cvs_dir".
                    " && chown -R ".$conf->{'user'}.":".$conf->{'user'}." mysociety");
           } else {
               shell("su", "-", $conf->{'user'}, "-c cd \"$vhost_dir\" && cvs -Q -d \"$cvs_root\" co mysociety/$cvs_dir");
           }
       } else {
           my $current_root = read_file("$d/Root");
           $current_root =~ s/\s*$//;
           die "CVSROOT in $d is \n\t$current_root\nwhen config says\n\t$cvs_root\n" if ($current_root ne $cvs_root);

           if ($cvs_user eq 'anon') {
               chdir("$vhost_dir/mysociety/$cvs_dir");
               # XXX detect errors.  
               system("cvs -Q diff -u") == 0 || die "Files checked out with anonymous CVS have been modified in $vhost_dir/mysociety/$cvs_dir";
           }
       }
   }
}

sub update_cvs {
    my ($cvs_user, $cvs_dirs) = @_;
    foreach my $cvs_dir (@{$cvs_dirs}) {
        die "unexpectedly missing cvs directory in update stage" if (! -d "$vhost_dir/mysociety/$cvs_dir/CVS");
        if ($cvs_user eq "") {
            shell("cd \"$vhost_dir/mysociety/$cvs_dir\" && cvs -Q update -dP && chown -R ".$conf->{'user'}.":".$conf->{'user'}." ../");
        } else {
            shell("su", "-", $conf->{'user'}, "-c cd \"$vhost_dir/mysociety/$cvs_dir\" && cvs -Q update -dP");
        }
    }
}

sub make_git_repository {
   my ($git_url_base, $git_user, $git_repository) = @_;
   my $d = "$vhost_dir/$git_repository/.git";
   my $git_url = "$git_url_base$git_repository.git";
   if (! -d $d) {
       if ($git_user eq "") { 
           shell("cd \"$vhost_dir\" && git clone $git_url");
       } else {
           shell("su", "-", $conf->{'user'}, "-c cd \"$vhost_dir\" && git clone $git_url");
       }
       shell("cd \"$vhost_dir/$git_repository\" && git submodule update --init");
   } else {
       chdir("$vhost_dir/$git_repository");
       my $current_url = `git config --get remote.origin.url`;
       $current_url =~ s/\s*$//;
       die "git remote.origin.url in $d is \n\t$current_url\nwhen config says\n\t$git_url\n" if ($current_url ne $git_url);

       if ($git_user eq 'anon') {
           shell("$mysociety_bin/git-safe-to-merge .")
       }
   }
   chdir($vhost_dir);
}

sub update_git {
    my ($git_user, $git_repository) = @_;
    die "unexpectedly missing .git directory in update stage" if (! -d "$vhost_dir/$git_repository/.git");
    if ($git_user eq "") {
        shell("cd \"$vhost_dir/$git_repository\" && git merge origin/master && git submodule update && chown -R ".$conf->{'user'}.":".$conf->{'user'}." ../");
    } else {
        shell("su", "-", $conf->{'user'}, "-c cd \"$vhost_dir/$git_repository\" && git pull && git submodule update");
    }
}

#####################################################################
# Shut down services, update, start services

# XXX bit nasty that we have to always call this. Should split into separate
# check and live update functions. But mainly harmless to update live config
# so hey.
update_config_and_schemas();

if ($action eq "stop") {
    stop_site();
    shell("/data/mysociety/bin/deploy-logger", "Stopped vhost $vhost");
} elsif ($action eq "update") {
    update_site();
    shell("/data/mysociety/bin/deploy-logger", "Updated vhost $vhost");
} elsif ($action eq "start") {
    start_site();
    shell("/data/mysociety/bin/deploy-logger", "Started vhost $vhost");
} elsif ($action eq "deploy") {
    stop_site();
    update_site();
    start_site();
    shell("/data/mysociety/bin/deploy-logger", "Deployed vhost $vhost")
        unless $vhost =~ /testharness/;
} elsif ($action eq "remove") {
    stop_site();
    remove_site();
    shell("/data/mysociety/bin/deploy-logger", "Removed vhost $vhost");
} else {
    die "unknown action";
}

sub check_packages {
    # Check Debian packages are all installed, if there is a conf/packages file
    foreach my $conf_dir (@{$conf->{conf_dir}}) {
        if ($cvs) {
            chdir "$mysociety_dir/$conf_dir";
            shell("cvs", "-Q", "update", "packages");
            if (-e "packages") {
                shell("/data/mysociety/bin/check-packages-installed", "packages")
            }
        } elsif ($git) {
            my $tmp_packages = mktemp("/tmp/deploy-vhost-packages-XXXXXXXX");
            chdir "$vhost_dir/$vcspath";
            shell("git show origin/master:$conf_dir/packages >$tmp_packages");
            shell("/data/mysociety/bin/check-packages-installed", "$tmp_packages");
            unlink $tmp_packages;
        } else {
            die "Unknown version control system";
        }
    }
}

# Halt any daemons, crontabs, email systems, and the web host itself
sub stop_site {
    # Stop daemons
    foreach my $daemon (keys %{$conf->{'daemons'}}) {
        shell("/etc/init.d/$daemon", "stop");
    }

    # Stop crontab
    unlink($cron_name);

    # Stop email forwarding 
    # XXX hmmm, maybe not such a good idea to stop this, as emails to, say
    # WhatDoTheyknow, would then not be delivered while deploying new version
    # of it. Really should replace with something that gets exim to try
    # redelivery?
    #if ($conf->{'email'}) {
    #    foreach my $email_user (keys %{$conf->{'email'}}) {
    #        unlink("/home/$email_user/.forward");
    #    }
    #}

    if(-s "$vhost_dir/docs/down.current.html") {
        unlink("$vhost_dir/docs/down.html");
        symlink("$vhost_dir/docs/down.current.html", "$vhost_dir/docs/down.html");
    } elsif (-s "$vhost_dir/docs/down.default.html") {
        unlink("$vhost_dir/docs/down.html");
        symlink("$vhost_dir/docs/down.default.html", "$vhost_dir/docs/down.html");
    } else {
        # Down notice
        open(FH, "> $vhost_dir/docs/.down.html.new") or die "failed to open .down.html.new";
        print FH <<END;
        <html>
        <head>
        <title>$vhost - Down for Maintenance</title>
        </head>
        <body>
        <p>Sorry, but $vhost is currently not available.  We're doing a spot of
        maintenance.  Check back in a few minutes, and everything should be
        restored to order.  Thanks for your patience!
        <p> &mdash; the <a href="http://www.mysociety.org/">mySociety</a> developers
        </body>
        </html> 
END
        close FH;
        unlink("$vhost_dir/docs/down.html");
        rename("$vhost_dir/docs/.down.html.new", "$vhost_dir/docs/down.html") or die "failed to rename to down.html";
        chown($user_uid, $user_gid, "$vhost_dir/docs/down.html");
    }
}

# Update a config dir
sub update_conf_dir {
    my ($conf_dir, $public, $unchecked_schemas) = @_;
    foreach my $glob (glob "$vhost_dir/$vcspath/$conf_dir/*-example") {
        $glob =~ m#^.*/(.*?)-example$#;
        my $name_part = $1;

        my $conf_file = "$vhost_dir/$vcspath/$conf_dir/$name_part"; # destination file

        my $old_umask = umask(0077);
        # find source template (.ugly) file
        my $conf_ugly_part;
        if ($cvs) {
            $conf_ugly_part = "$conf_dir/$name_part"; # e.g. foi/config/general
        } elsif ($git) {
            $conf_ugly_part = "$vcspath/$conf_dir/$name_part"; # e.g. whatdotheyknow/config/general
        } else {
            die "Unknown version control system";
        }
        $conf_ugly_part =~ s#/#_#g;
        my $conf_ugly_file = "$servers_dir/vhosts/$conf_ugly_part.ugly";
        # update the conf/general (or whatever) template in private CVS
        chdir "$servers_dir/vhosts";
        shell("cvs", "-Q", "update", "$conf_ugly_part.ugly");
        # update example we'll be comparing against, to make sure no missing entries.
        # For public conf files, use the example in the main public checkout. For 
        # private, use the example in the vhost conf dir.
        my $example_file;
        if ($cvs) {
            my $example_file_dir;
            if ($public) {
                $example_file_dir = "$mysociety_dir/$conf_dir";
            } else {
                $example_file_dir = "$vhost_dir/$vcspath/$conf_dir";
            }
            chdir $example_file_dir;
            shell("cvs", "-Q", "update", "$name_part-example");
            $example_file = "$example_file_dir/$name_part-example";
        } elsif ($git) {
            $example_file = mktemp("/tmp/deploy-vhost-$name_part-example-XXXXXXXX");
            chdir "$vhost_dir/$vcspath";
            shell("git show origin/master:$conf_dir/$name_part-example >$example_file");
        } else {
            die "Unknown version control system";
        }
        # check destination file hasn't been separately modified
        chdir $mysociety_dir;
        my $make_conf = 1;
        if (-e $conf_file) {
            # XXX detect errors
            if (system("diff", "-u", "$conf_file.deployed", "$conf_file") != 0) {
                print STDERR "Warning: $conf_file was changed directly since last update from\n";
                print STDERR "template file $conf_ugly_file, so has not been updated.\n";
                $make_conf = 0;
            }
        }
        if ($make_conf) {
            # call mugly to generate from template
            shell("$mysociety_bin/mugly", "-O", "$conf_file.tmp", "-p", "$settings_file", "$conf_ugly_file");
            if ($name_part eq 'general') {
                # test contents of new configuration file before copying it over
                chdir $mysociety_bin;
                shell("$mysociety_bin/compareconfig.pl", "$conf_file.tmp", $example_file);
            }
            # copy into place
            copy("$conf_file.tmp", "$conf_file.deployed");
            chown($user_uid, $user_gid, "$conf_file.deployed");
            copy("$conf_file.tmp", "$conf_file");
            chown($user_uid, $user_gid, "$conf_file");
            unlink("$conf_file.tmp") or die "couldn't unlink $conf_file.tmp";
        } else {
            if ($name_part eq 'general') {
                # test contents of configuration file before copying it over
                chdir $mysociety_bin;
                shell("$mysociety_bin/compareconfig.pl", "$conf_file", $example_file);
            }
        }
        # clear up temporary example file in git case
        if ($git) {
            unlink($example_file);
        }
        # now we use this configuration
        mySociety::Config::set_file($conf_file);
        umask($old_umask);

        # Check pgsql databases are up to date
        foreach my $psql_conf_prefix (keys %{$conf->{'psql_schemas'}}) {
            my $psql_schema = $conf->{'psql_schemas'}->{$psql_conf_prefix};
            my $psql_name = mySociety::Config::get($psql_conf_prefix.'_DB_NAME', 0);

            # It's OK for the configuration info for a DB to be absent from
            # any given conf file, as long as it's in one of them
            if ($psql_name){

                if (exists($unchecked_schemas->{$psql_conf_prefix})){
                    delete $unchecked_schemas->{$psql_conf_prefix};
                }

                my $psql_host = mySociety::Config::get($psql_conf_prefix.'_DB_HOST', 'localhost');
                my $psql_port = mySociety::Config::get($psql_conf_prefix.'_DB_PORT', 5432);
                my $psql_user = mySociety::Config::get($psql_conf_prefix.'_DB_USER');

                die "not implemented" if $git;
                chdir $mysociety_dir;
                shell("cvs", "-Q", "update", "$psql_schema");
                chdir $mysociety_bin;
                # It isn't safe to pass the password over the command line as that can be
                # seen by other processes, instead put it in in ~/.pgpass (see
                # mysociety/bin/generate-pgpass). And no, PGPASSWORD isn't safer, as on
                # some systems the environment can be seen in other processes.
                shell("./psql-schema-compare", $mysociety_dir.'/'.$psql_schema, $conf->{'user'}, $psql_name, $psql_user, $psql_host, $psql_port);
            }
        }

        # Check MySQL databases are up to date
        foreach my $mysql_schema (@{$conf->{'mysql_schemas'}}) {
           my $mysql_name = mySociety::Config::get('DB_NAME', 0);

           # It's OK for the configuration info for a DB to be absent from
           # any given conf file, as long as it's in one of them
           if ($mysql_name) {
                if (exists($unchecked_schemas->{$mysql_schema})){
                   delete $unchecked_schemas->{$mysql_schema};
                }

                my $mysql_host = mySociety::Config::get('DB_HOST', 'localhost');
                my $mysql_port = mySociety::Config::get('DB_PORT', 3306);
                my $mysql_user = mySociety::Config::get('DB_USER');

                die "not implemented" if $git;
                chdir $mysociety_dir;
                shell("cvs", "-Q", "update", "$mysql_schema");
                chdir $mysociety_bin;
                # It isn't safe to pass the password over the command line or in the
                # environment as that can be seen by other processes.
                shell("./mysql-schema-compare", $mysociety_dir.'/'.$mysql_schema, $conf->{'user'}, $mysql_name, $mysql_user, $mysql_host, $mysql_port);
            }
        }
    }
}

# Check that config files and database files have been updated
sub update_config_and_schemas {
    # Make a list of all the database schemas to be checked
    my %unchecked_schemas = map {$_ => 1} keys %{$conf->{'psql_schemas'}}, @{$conf->{mysql_schemas}};

    # Generate all conf files from conf/*-example template files e.g. conf/general
    foreach my $conf_dir (@{$conf->{conf_dir}}) {
         update_conf_dir($conf_dir, 1, \%unchecked_schemas);        
    }
    foreach my $conf_dir(@{$conf->{private_conf_dir}}){
         update_conf_dir($conf_dir, 0, \%unchecked_schemas);
    }
     
    # exit if there are any schemas not covered by a config
    foreach my $unchecked_schema (keys %unchecked_schemas) {
        die "$unchecked_schema not configured in conf/general file(s)";
    }
}

sub update_site {
    if ($cvs) {
        # Update from CVS
        update_cvs($conf->{'cvs_user'}, $conf->{'cvs_dirs'});
        if (exists($conf->{'private_cvs_dirs'})){
            update_cvs($conf->{'private_cvs_user'}, $conf->{'private_cvs_dirs'});
        }
    } elsif ($git) {
        # Update from git
        update_git($conf->{'git_user'}, $conf->{'git_repository'});
    } else {
        die "Unknown version control system";
    }

    # Run any extra executables
    foreach my $exec_extra (@{$conf->{'exec_extras'}}) {
        chdir("$vhost_dir/$vcspath");
        `pwd`;
        shell("su", $conf->{'user'}, "-c $exec_extra");
    }

    # Prompt apache to reread files, on machines which have apache
    apache_graceful();
}

sub start_site {
    # Up notice
    unlink("$vhost_dir/docs/down.html") or die "couldn't unlink down.html";

    # Start daemons
    foreach my $daemon (keys %{$conf->{'daemons'}}) {
        shell("/etc/init.d/$daemon", "start");
    }

    # Make or remove crontab
    my $ok = 0;
    if ($conf->{'crontab'}) {
        if ($conf->{'crontab'} eq '1') {
            $ok = 1;
        } else {
            if ($hostname eq $conf->{'crontab'}) {
                $ok = 1;
            }
        }
    }
    if ($ok) {
        if ($cvs) {
            chdir $mysociety_dir;
            foreach my $conf_dir (@{$conf->{conf_dir}}) {
                shell("cvs", "-Q", "update", "$conf_dir/crontab.ugly");
                shell("$mysociety_bin/mugly", "-O", $cron_name, "-p", "$settings_file", "$mysociety_dir/$conf_dir/crontab.ugly");
            }
        } elsif ($git) {
            foreach my $conf_dir (@{$conf->{conf_dir}}) {
                my $tmp_crontab_ugly = mktemp("/tmp/deploy-vhost-crontab.ugly-XXXXXXXX");
                chdir "$vhost_dir/$vcspath";
                shell("git show origin/master:$conf_dir/crontab.ugly >$tmp_crontab_ugly");
                shell("$mysociety_bin/mugly", "-O", $cron_name, "-p", "$settings_file", "$tmp_crontab_ugly");
                unlink $tmp_crontab_ugly;
            }
        } else {
            die "Unknown version control system";
        }
    } else {
        unlink($cron_name);
    }

    # Make .forward files
    if ($conf->{'email'}) {
        foreach my $email_user (keys %{$conf->{'email'}}) {
            my $email_pipeto = $conf->{'email'}->{$email_user};
            shell("su", "-", $email_user, "-c echo \"|$vhost_dir/$vcspath/$email_pipeto\" >~$email_user/.forward");
        }
    }
}

# Remove crontabs, vhost config etc.
sub remove_site {
    # Remove daemons
    foreach my $daemon (keys %{$conf->{'daemons'}}) {
        unlink("/etc/init.d/$daemon");
    }

    # Remove crontab
    unlink($cron_name);

    # Remove email forwarding 
    if ($conf->{'email'}) {
        foreach my $email_user (keys %{$conf->{'email'}}) {
            unlink("/home/$email_user/.forward");
        }
    }

    # Remove Apache virtual host config
    unlink("/etc/apache/virtualhosts.d/$vhost.conf");
    apache_graceful();

    print "Config files removed, please tidy data/vhost/$vhost yourself.\n";
}


