#!/usr/bin/perl -w
#
# deploy-vhost:
# Deploy a virtual host.
#
# Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
# Email: francis@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: deploy-vhost,v 1.10 2005-12-19 22:52:32 maint Exp $';

package main;

use strict;
require 5.8.0;

use FindBin;
use lib "$FindBin::Bin/../perllib";
my $mysociety_bin = $FindBin::Bin;
my $servers_dir = "$FindBin::Bin/../../servers";
my $mysociety_dir = "$FindBin::Bin/../../mysociety";

use mySociety::Util;
use mySociety::Config;

use POSIX qw(getuid);
use Data::Dumper;
use File::Slurp;
use File::Copy;
use File::Temp qw(tempfile);

#####################################################################
# General functions

sub make_dir {
    my $dir = shift;
    if (! -d $dir) {
        mkdir($dir) || die "failed to mkdir '$dir'";
    }
}

sub make_symlink {
    my ($a, $b) = @_;
    my $current = readlink($b);
    if (!$current) {
        symlink($a, $b) || die "failed to make symlink '$a'->'$b'";
    }
}

sub shell {
	system(@_) == 0 || die "system call failed: " . join(" ", @_);
}

#####################################################################
# Main code

# Read in configuration file
our ($vhosts, $sites);
require "$servers_dir/vhosts.pl";

# Check command line parameters, look up in config file
die "Specify virtual host name as only parameter" if scalar(@ARGV) != 1;
my $vhost = $ARGV[0];
my $vhost_conf = $vhosts->{$vhost};
die "vhost '$vhost' is not in vhosts.pl" if !$vhost_conf;
my $site = $vhost_conf->{'site'};
die "site not specified for '$vhost' in vhosts.pl" if !$site;
my $site_conf = $sites->{$site};
die "site '$site' is not in vhosts.pl" if !$site_conf;
my $vhost_dir = "/data/vhost/$vhost";

# Merge vhost and site configs together
my $conf;
foreach my $key ( keys %$site_conf ) { $conf->{$key} = $site_conf->{$key}; }
foreach my $key ( keys %$vhost_conf ) { $conf->{$key} = $vhost_conf->{$key}; }
die "must specify 'staging' in vhost config" if (!exists($conf->{staging}));

# Look up some values
my ($user_login, $user_pass, $user_uid, $user_gid) = getpwnam($conf->{'user'});
die "Unknown user '".$conf->{'user'}."'" if !$user_uid;
die "Unknown group for user '".$conf->{'user'}."'" if !$user_gid;
my $user = $conf->{'user'};
my $group = getgrgid($user_gid);

#####################################################################
# Make directories and conf files, check database and conf files

# Create directories and symlink to docs
make_dir("/data");
make_dir("/data/vhost");
make_dir("$vhost_dir");
chown($user_uid, $user_gid, "$vhost_dir");
make_dir("$vhost_dir/logs");
chown($user_uid, $user_gid, "$vhost_dir/logs");
make_symlink("mysociety/".$conf->{'web_dir'}, "$vhost_dir/docs");
shell("chown", "-h", "$user_uid:$user_gid", "$vhost_dir/docs"); # perl's chown doesn't do symlinks

# Initial checkout, for CVS directories which don't exist
my $cvsroot = ($conf->{'cvs_user'} eq 'anon' ?
	':pserver:anonymous@cvs.mysociety.org:/repos' :
	$conf->{'cvs_user'} . "\@cvs.mysociety.org:/user/local/cvs");
foreach my $cvs_dir (@{$conf->{'cvs_dirs'}}) {
    my $d = "$vhost_dir/mysociety/$cvs_dir/CVS";
	if (! -d $d) {
		chdir($vhost_dir);
		shell("su", $conf->{'user'}, "cvs -Q -d \"$cvsroot\" co mysociety/$cvs_dir");
	} else {
        my $current_root = read_file("$d/Root");
        $current_root =~ s/\s*$//;
        die "CVSROOT in $d is \n\t$current_root\nwhen config says\n\t$cvsroot\n" if ($current_root ne $cvsroot);
    }
}

# Make cache directories
# TODO: Somewhere at the end we can clear the cache directories automatically
foreach my $public_cache_dir (@{$conf->{'public_cache_dirs'}}) {
    make_dir("$vhost_dir/$public_cache_dir");
    chown($user_uid, $user_gid, "$vhost_dir/$public_cache_dir");
}

# Make some settings
$vhost =~ m/^([^.]+)\.(.*)$/;
my $vhost_first = $1;
my $vhost_rest = $2;
# Create settings file
my $settings_file_namepart = "settings-autogen.pl";
my $settings_file = "$vhost_dir/$settings_file_namepart";
my $global_settings_file = "/etc/mysociety/config-settings.pl";
my $global_settings = read_file($global_settings_file) or die "failed to read /etc/mysociety/config-settings.pl, which is made by deploy-configuration";
open(FH, "> $settings_file") or die "failed to open $settings_file for write";
print FH <<END;
#
# $settings_file_namepart
#

\$vhost = '$vhost';
\$staging = '$conf->{'staging'}';
\$vhost_first = '$vhost_first';
\$vhost_rest = '$vhost_rest';
\$user = '$user';
\$group = '$group';
\$conf_dir = '$conf->{'conf_dir'}';
\$wildcard_vhost = '$conf->{'wildcard_vhost'}';
END
print FH Dumper($conf->{'public_cache_dirs'});
print FH "\$public_cache_dirs = \$VAR1;\n";
print FH Dumper($conf->{'redirects'});
print FH "\$redirects = \$VAR1;\n";
print FH <<END;

sub pgpw {
    \$_ = shift;
    \$_ = `$mysociety_bin/pgpw \$_`;
    s/\\s+\$//;
    return \$_;
}


# ---------------------------------------------------------
# Settings from here on are copied from:
# $global_settings_file

$global_settings
END
close FH;
chown($user_uid, $user_gid, $settings_file);

# Generate daemon init scripts from templates
foreach my $daemon (keys %{$conf->{'daemons'}}) {
    my $daemon_mugly = $mysociety_dir.'/'.$conf->{'conf_dir'}.'/'.$conf->{'daemons'}->{$daemon};
    my ($fh, $filename) = tempfile();
    open(FH, ">$filename") or die "failed to open $filename for write";
    print FH "\$daemon_name = '$daemon';\n";
    close FH;
    shell("$mysociety_bin/mugly", "-O", "/etc/init.d/$daemon", "-p", "$settings_file", "-p", "$filename", "$daemon_mugly");
    unlink($filename);
    chmod 0755, "/etc/init.d/$daemon";
    system("update-rc.d $daemon defaults | grep -v \"System startup links for .* already exist\"");
}

# Generate conf/general file from its template file
my $conf_dir = $conf->{'conf_dir'};
my $conf_file = "$vhost_dir/mysociety/$conf_dir/general"; # destination file
my $old_umask = umask(0077);
# find source template (.ugly) file
my $conf_ugly_part = $conf_dir . "/general";
$conf_ugly_part =~ s#/#_#g;
my $conf_ugly_file = "$servers_dir/vhosts/$conf_ugly_part.ugly";
# check destination file hasn't been separately modified
if (-e $conf_file) {
   system("diff", "-u", "$conf_file.deployed", "$conf_file") == 0 || die "$conf_file was changed directly since last deployed, so cannot update from template";
}
# call mugly to generate from template
shell("$mysociety_bin/mugly", "-O", "$conf_file.tmp", "-p", "$settings_file", "$conf_ugly_file");
# test contents of new configuration file before copying it over
chdir $mysociety_dir;
shell("cvs", "-Q", "update", "$conf_dir/general-example");
chdir $mysociety_bin;
shell("$mysociety_bin/compareconfig.pl", "$conf_file.tmp", "$mysociety_dir/$conf_dir/general-example");
# copy into place
copy("$conf_file.tmp", "$conf_file.deployed");
chown($user_uid, $user_gid, "$conf_file.deployed");
copy("$conf_file.tmp", "$conf_file");
chown($user_uid, $user_gid, "$conf_file");
unlink("$conf_file.tmp") or die "couldn't unlink $conf_file.tmp";
# now we use this configuration
mySociety::Config::set_file($conf_file);
umask($old_umask);

# Check pgsql databases are up to date
foreach my $psql_conf_prefix (keys %{$conf->{'psql_schemas'}}) {
	my $psql_schema = $conf->{'psql_schemas'}->{$psql_conf_prefix};

	my $psql_host = mySociety::Config::get($psql_conf_prefix.'_DB_HOST', 'localhost');
	my $psql_port = mySociety::Config::get($psql_conf_prefix.'_DB_PORT', 5432);
	my $psql_name = mySociety::Config::get($psql_conf_prefix.'_DB_NAME');
    die "$psql_conf_prefix not configured in conf/general file" if !$psql_name;
	my $psql_user = mySociety::Config::get($psql_conf_prefix.'_DB_USER');
	my $psql_pass = mySociety::Config::get($psql_conf_prefix.'_DB_PASS');
	
	chdir $mysociety_dir;
	shell("cvs", "-Q", "update", "$psql_schema");
	chdir $mysociety_bin;
	shell("./psql-schema-compare", $mysociety_dir.'/'.$psql_schema, $conf->{'user'}, $psql_name, $psql_user, $psql_pass);
}

# Create httpd configuration stanza
shell("$mysociety_bin/mugly", "-O", "/etc/apache/virtualhosts.d/$vhost.conf", "-p", "$settings_file", "$servers_dir/vhosts/single-vhost.conf.ugly");

#####################################################################
# Shut down services, update, start services

# Stop daemons
foreach my $daemon (keys %{$conf->{'daemons'}}) {
    shell("/etc/init.d/$daemon", "stop");
}

# Down notice
open(FH, "> $vhost_dir/docs/.down.html.new") or die "failed to open .down.html.new";
print FH <<END;
<html>
<head>
<title>$vhost - Down for Maintenance</title>
</head>
<body>
<p>Sorry, but $vhost is currently not available.  We're doing a spot of
maintenance.  Check back in a few minutes, and everything should be
restored to order.  Thanks for your patience!
<p> &mdash; the <a href="http://www.mysociety.org/">mySociety</a> developers
</body>
</html> 
END
close FH;
unlink("$vhost_dir/docs/down.html");
rename("$vhost_dir/docs/.down.html.new", "$vhost_dir/docs/down.html") or die "failed to rename to down.html";
chown($user_uid, $user_gid, "$vhost_dir/docs/down.html");

# Update from CVS
foreach my $cvs_dir (@{$conf->{'cvs_dirs'}}) {
	die "unexpectedly missing cvs directory in update stage" if (! -d "$vhost_dir/mysociety/$cvs_dir/CVS");
    chdir("$vhost_dir/mysociety/$cvs_dir");
    shell("su", $conf->{'user'}, "cvs -Q update -dP");
}

# Run any extra executables
foreach my $exec_extra (@{$conf->{'exec_extras'}}) {
    chdir("$vhost_dir/mysociety");
    shell("su", $conf->{'user'}, "$exec_extra");
}

# Prompt apache to reread files
shell("apachectl", "graceful");

# Up notice
unlink("$vhost_dir/docs/down.html") or die "couldn't unlink down.html";

# Start daemons
foreach my $daemon (keys %{$conf->{'daemons'}}) {
    shell("/etc/init.d/$daemon", "start");
}

# Make crontab
chdir $mysociety_dir;
shell("cvs", "-Q", "update", "$conf_dir/crontab.ugly");
my $cron_name = "vhost-$vhost";
$cron_name =~ s/\./-/g;
shell("$mysociety_bin/mugly", "-O", "/etc/cron.d/$cron_name", "-p", "$settings_file", "$mysociety_dir/$conf_dir/crontab.ugly");


