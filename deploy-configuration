#!/usr/bin/perl -w
#
# deploy-configuration:
# Deploy the configuration of a server, using a tree of configuration files
# (presumably under revision control) and a file of definitions.
#
# We construct a temporary tree of configuration files by applying mugly to
# files in the input tree.
#
# Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: deploy-configuration,v 1.6 2005-11-18 13:04:32 chris Exp $';

use strict;
require 5.8.0;

use FindBin;
use lib "$FindBin::Bin/../perllib";

use Errno;
#use Fcntl qw(:mode);
use File::Find;
use File::stat;
use IO::File;
use POSIX;

use mySociety::Util;

my $default_uid = 0;
my $default_gid = 0;
my $default_file_mode = 0640;
my $default_dir_mode = 0750;

my $mugly_bin = "$FindBin::Bin/mugly";

sub verbose (@) {
    print STDERR @_;
}

# install_file SOURCE DESTINATION KEY VALUE ...
# Install the file at SOURCE to DESTINATION. Optionally set the uid, gid and
# mode of the installed file using appropriate KEYs and VALUEs.
sub install_file ($$%) {
    my ($source, $dest, %options) = @_;

    my $st = stat($source) || die "$source: stat: $!";
    
    $options{uid} ||= $st->uid();
    $options{gid} ||= $st->gid();
    $options{mode} ||= $st->mode() & 07777;

    my $f = new IO::File($source, O_RDONLY)
                || die "$source: open: $!";
    my $g;
    my $tmpname;
    while (1) {
        $tempname = sprintf('%s.%08x', $dest, int(rand(0xffffffff)))
        $g = new IO::File($tempname, O_WRONLY | O_CREAT | O_EXCL, $options->{mode});
        if ($g) {
            last;
        } elsif (!$!{EEXIST}) {
            die "$tempname: open: $!";
        }
    }
    my $buf = '';
    my $n;
    do {
        $n = $f->read($buf, 65536);
        if (!defined($n)) {
            unlink($tempname);
            die "$source: read: $!";
        }
        if (!$g->print($buf)) {
            unlink($tempname);
            die "$dest: write: $!";
        }
    } while ($n > 0);
    $f->close();
    if (!$g->close()) {
        unlink($tempname);
        die "$tempname: close: $!";
    }
    if (!chown($options->{uid}, $options->{gid}, $tempname)) {
        unlink($tempname);
        die "$tempname: chown: $!";
    }
    if (!rename($tempname, $dest)) {
        unlink($tempname);
        die "$tempname: rename: $!";
    }
}

# install_symlink SOURCE DESTINATION KEY VALUE
# Install the symlink at SOURCE to DESTINATION. Optionally set the uid and gid
# of the symlink using appropriate KEYs and VALUEs.
sub install_symlink ($$%) {
    my ($source, $dest, %options) = @_;

    my $st = lstat($source) || die "$source: lstat: $!";
    my $target = readlink($source) || die "$source: readlink: $!";

    $options{uid} ||= $st->uid();
    $options{gid} ||= $st->gid();

    my $tempname;
    while (1) {
        $tempname = sprintf('%s.%08x', $dest, int(rand(0xffffffff)));
        if (symlink($target, $tempname)) {
            last;
        } elsif (!$!{EEXIST}) {
            die "$tempname: symlink: $!";
        }
    }

    system('chown', '-h', "$options{uid}:$options{gid}", $tempname);
    if ($? == -1) {
        unlink($tempname);
        die "chown -h: exec: $!";
    } elsif ($? & 127) {
        unlink($tempname);
        die "chown -h $uid:$gid $tempname: killed by signal " . ($? & 127);
    } elsif ($? >> 8) {
        unlink($tempname);
        die "chown -h $uid:$gid $tempname: exited with nonzero status " . ($? >> 8);
    }

    if (!rename($tempname, $dest)) {
        unlink($tempname);
        die "$tempname: rename: $!";
    }
}

# read_perms DIRECTORY
# If there is in DIRECTORY a _perm file indicating ownership and permissions
# for files in that directory, read its contents and return them as a reference
# to a hash of FILENAME => [UID, GID, MODE]. Dies on error.
sub read_perms ($) {
    my $indir = shift;
    $indir =~ s#(?<!^)/$##;
    my $f = new IO::File("$indir/_perm");
    if (!$f) {
        if ($!{ENOENT}) {
            return { };
        } else {
            die "$indir/_perm: $!";
        }
    }

    my $h = { };
    my $n = 0;
    while (defined(my $line = $f->getline())) {
        ++$n;
        chomp($line);
        # Skip lines which are blank or begin #.
        next if ($line =~ /^#/ || $line =~ /^\s*$/);

        $line =~ s/^\s+//;
        $line =~ s/\s+$//;

        my ($name, $owner, $mode) = split(/\s+/, $line);

        my ($uid, $gid, $perm);

        # Ownership.
        if ($owner =~ /([^:]+):([^:]+)/) {
            ($uid, $gid) = ($1, $2);
            if ($uid !~ /^(0|[1-9][0-9]*)$/) {
                $uid = getpwnam($uid)
                    || die "$indir/_perm:$n: '$1' is not a valid UID or username";
            }
            if ($gid !~ /^(0|[1-9][0-9]*)$/) {
                $gid = getgrnam($gid)
                    || die "$indir/_perm:$n: '$2' is not a valid GID or groupname";
            }
        } elsif ($owner ne '-') {
            die "$indir/_perm:$n: '$owner' is not a valid owner string (should be U:G)";
        }

        # Permissions.
        if ($mode eq '-') {
            ;
        } elsif ($mode =~ /^0?[0-7]+$/) {
            $perm = oct($mode);
        } elsif (!defined($perm = mySociety::Util::symbolic_permissions(0, $mode))) {
            die "$indir/_perm:$n: '$mode' is neither a valid octal nor a symbolic mode";
        }

        $uid = $default_uid if (!defined($uid));
        $gid = $default_gid if (!defined($uid));
        if (!defined($perm)) {
            my $st = stat("$indir/$name");
            if ($st) {
                $perm = $st->mode() & 07777;
            } else {
                $perm = $default_file_mode;
            }
        }

        verbose(sprintf("%s/%s: chown %d:%d; chmod 0%o\n", $indir, $name, $uid, $gid, $perm));

        $h->{name} = [$uid, $gid, $perm];
    }

    $f->close();
    die "$indir/_perm:$n: $!" if ($f->error());

    return $h;
}

# process_directory INDIR OUTDIR SETTINGS
# Process the contents of INDIR (configuration file templates under version
# control), writing it into OUTDIR, and using the given SETTINGS file (which is
# passed by the -p option to mugly). Operates recursively, processing files
# before subdirectories. Dies on error.
sub process_directory ($$$);
sub process_directory ($$$) {
    my ($indir, $outdir, $settings) = @_;
    $indir =~ s#(?<!^)/$##;
    $outdir =~ s#(?<!^)/$##;

    verbose("processing $indir -> $outdir\n");
    my $perm = read_perms($indir);

    my %havefile;
    my @subdirs = ( );
    opendir(D, $indir) or die "$indir: opendir: $!";
    while (defined(my $name = readdir(D))) {
        # XXX should have an exclusion list (maybe use .cvsignore?)
        next if ($name eq '_perm' || $name eq '.' || $name eq '..' || $name eq 'CVS');
        die "$indir/$name: already created $name, from $havefile{$name}"
            if (exists($havefile{$name}));
        my $s = lstat("$indir/$name");
        my $mode = $s->mode() & 07777;
        my $is_symlink = 0;
        if (S_ISDIR($s->mode())) {
            # This is a directory. Create it in the output, and add it to the
            # list of subdirectories into which to recurse.
            my $m = exists($perm->{$name}) ? $perm->{$name} : $mode;
            verbose(sprintf("mkdir -m 0%o %s\n", $m, "$outdir/$name"));
            mkdir("$outdir/$name", $m) or die "$outdir/$name: mkdir: $!";
            $havefile{$name} = $name;
            push(@subdirs, $name);
        } elsif (S_ISREG($s->mode())) {
            if ($name =~ /.\.symlink$/) {
                # File specifies a symlink which should be created.
                my $f = new IO::File("$indir/$name")
                    or die "$indir/$name: open: $!";
                my $target = join('', $f->getlines());
                die "$indir/$name: read: $!" if ($f->error());
                $f->close();
                $name =~ s/\.symlink$//;
                die "$indir/$name: already created $name, from $havefile{$name}"
                    if (exists($havefile{$name}));
                $target =~ s#\n$##s;
                die "$indir/$name.symlink: symlink file syntax is 'To: TARGET\\n'" if ($target !~ /^To:/);
                $target =~ s#^To:\s*##;
                die "$indir/$name.symlink: specified symlink target contains illegal characters" if ($target =~ /[\0\n]/);
                print STDERR "$indir/$name.symlink: warning: symlink target is absolute\n" if ($target =~ m#^/#);
                verbose(sprintf("ln -s %s %s\n", $target, "$outdir/$name"));
                symlink($target, "$outdir/$name") or die "$outdir/$name: symlink: $!";
                $havefile{$name} = "$name.symlink";
                $is_symlink = 1;
            } elsif ($name =~ /.\.ugly$/) {
                # File specifies macro source.
                $name =~ s/\.ugly$//;
                die "$indir/$name: already created $name, from $havefile{$name}"
                    if (exists($havefile{$name}));
                verbose(sprintf("mugly -O %s -p %s %s\n", "$outdir/$name", $settings, "$indir/$name.ugly"));
                system($mugly_bin, '-O', "$outdir/$name", "-p", $settings, "$indir/$name.ugly");
                if ($? == -1) {
                    die "$mugly_bin: exec: $!";
                } elsif ($? & 127) {
                    die "$mugly_bin ... $indir/$name.ugly: killed by signal " . ($? & 127);
                } elsif ($? >> 8) {
                    die "$mugly_bin ... $indir/$name.ugly: exited with nonzero status " . ($? >> 8);
                }
                $havefile{$name} = "$name.ugly";
            } else {
                verbose(sprintf("cp %s %s\n", "$indir/$name", "$outdir/$name"));
                install_file("$indir/$name", "$outdir/$name",
                              mode => exists($perm->{$name}) ? $perm->{$name} : $mode);
                $havefile{$name} = $name;
            }
        } else {
            die "$indir/$name: not a regular file or a directory";
        }

        my ($uid, $gid) = ($default_uid, $default_gid);
        if (exists($perm->{$name})) {
            ($uid, $gid) = @{$perm->{$name}};
            $mode = $perm->{$name}->[2];
        }
        if ($is_symlink) {
            # perl lacks lchown
            system('chown', '-h', "$uid:$gid", "$outdir/$name");
            if ($? == -1) {
                die "chown -h: exec: $!";
            } elsif ($? & 127) {
                die "chown -h $uid:$gid $outdir/$name: killed by signal " . ($? & 127);
            } elsif ($? >> 8) {
                die "chown -h $uid:$gid $outdir/$name: exited with nonzero status " . ($? >> 8);
            }
        } else {
            chown($uid, $gid, "$outdir/$name")
                or die "$outdir/$name: chown: $!";
            chmod($mode, "$outdir/$name")
                or die "$outdir/$name: chmod: $!";
        }
    }
    closedir(D);

    foreach my $dir (@subdirs) {
        process_directory("$indir/$dir", "$outdir/$dir", $settings);
    }
}

# install_files INDIR [OUTDIR]
# Install files from INDIR (presumably, the OUTDIR previously passed to
# process_files) onto the real system to OUTDIR, or, if it is not specified, /.
sub install_files ($) {
    my ($indir, $outdir) = @_;
    $indir =~ s#(?<!^)/$##;
    $outdir ||= '/';

    my @subdirs = ( );
    opendir(D, $indir) or die "$indir: opendir: $!";
    while (defined(my $name = readdir(D))) {
        my $outname = $outdir eq '/' ? "$outdir$name" : "$outdir/$name";
        my $s = lstat("$indir/$name") || die "$dir/$name: lstat: $!";

        if (S_ISDIR("$indir/$name")) {
            mkdir($outname, $st->mode() & 07777)
                || die "$outname: mkdir: $!";
            chown($st->uid(), $st->gid(), $outname)
                || die "$outname: chown: $!";
            push(@subdirs, $name);
        } elsif (S_ISREG("$indir/$name")) {
            install_file("$indir/$name", $outdir);
        } elsif (S_ISLNK("$indir/$name")) {
            install_symlink("$indir/$name", $outdir);
        }
    }
    closedir(D);
    
    foreach my $dir (@subdirs) {
        my $outname = $outdir eq '/' ? "$outdir$dir" : "$outdir/$dir";
        install_files("$indir/$dir", $outname);
    }
}

die "must be run as root" if (getuid() != 0);

die "two arguments must be template configuration tree and settings file" if (@ARGV != 2);
my ($tree, $settings) = @ARGV;

die "first argument must be a directory" if (!-d $tree);
die "second argument must be a file" if (!-f $settings);

my $tempdir = mySociety::Util::tempdir();

verbose("temporary directory is $tempdir\n");

process_directory($tree, $tempdir, $settings);

mySociety::Util::tempdir_cleanup($tempdir);
