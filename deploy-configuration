#!/usr/bin/perl -w
#
# deploy-configuration:
# Deploy the configuration of a server, using a tree of configuration files
# (presumably under revision control) and a file of definitions.
#
# This program does three things:
#
# - Check that the currently-installed configuration files are the same as
#   those which were last installed (using a copy of those installed on the
#   last run stored in a tar file).
#
# - Construct a set of files suitable for installation from those in version
#   control, by processing _perm, *.symlink and *.ugly files where appropriate,
#   and copying everything else.
#
# - Install the constructed set of files onto the real filesystem.
#
# Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: deploy-configuration,v 1.9 2005-11-18 18:58:01 chris Exp $';

package Oops;

use strict;
@Oops::ISA = qw(Error::Simple);

use strict;
require 5.8.0;

use FindBin;
use lib "$FindBin::Bin/../perllib";

use Archive::Tar;
use Archive::Tar::Constant;
use Errno;
use Error qw(:try);
use Fcntl qw(:mode);
use File::Find;
use File::Spec;
use File::stat;
use IO::File;
use POSIX qw(getuid);

use mySociety::Util;

my $default_uid = 0;
my $default_gid = 0;
my $default_file_mode = 0640;
my $default_dir_mode = 0750;

my $mugly_bin = "$FindBin::Bin/mugly";

my $be_verbose = 0;
sub verbose (@) {
    return unless ($be_verbose);
    print STDERR @_;
}

# install_file SOURCE DESTINATION DATA KEY VALUE ...
# Install the file at SOURCE to DESTINATION. Optionally set the uid, gid and
# mode of the installed file using appropriate KEYs and VALUEs. If DATA is
# defined, it should be a reference to a scalar into which the contents of the
# file will be stored.
sub install_file ($$%) {
    my ($source, $dest, $data, %options) = @_;

    my $st = stat($source) || throw Oops("$source: stat: $!");
    
    $options{uid} ||= $st->uid();
    $options{gid} ||= $st->gid();
    $options{mode} ||= $st->mode() & 07777;

    my $f = new IO::File($source, O_RDONLY)
                || throw Oops("$source: open: $!");
    my $g;
    my $tempname;
    try {
        while (1) {
            $tempname = sprintf('%s.%08x', $dest, int(rand(0xffffffff)));
            $g = new IO::File($tempname, O_WRONLY | O_CREAT | O_EXCL, $options{mode});
            if ($g) {
                last;
            } elsif (!$!{EEXIST}) {
                throw Oops("$tempname: open: $!");
            }
        }
        my $buf = '';
        my $n;
        do {
            $n = $f->read($buf, 65536);
            throw Oops("$source: read: $!") if (!defined($n));
            $$data .= $buf if ($data);
            $g->print($buf) || throw Oops("$dest: write: $!");
        } while ($n > 0);
        $f->close();
        $g->close() || throw Oops("$tempname: close: $!");
        chown($options{uid}, $options{gid}, $tempname)
            || throw Oops("$tempname: chown: $!");
        rename($tempname, $dest)
            || throw Oops("$tempname: rename: $!");
    } finally {
        unlink($tempname) if (defined($tempname));
    };
}

# install_symlink SOURCE DESTINATION KEY VALUE
# Install the symlink at SOURCE to DESTINATION. Optionally set the uid and gid
# of the symlink using appropriate KEYs and VALUEs.
sub install_symlink ($$%) {
    my ($source, $dest, %options) = @_;

    my $st = lstat($source) || throw Oops("$source: lstat: $!");
    my $target = readlink($source) || throw Oops("$source: readlink: $!");

    $options{uid} ||= $st->uid();
    $options{gid} ||= $st->gid();

    my $tempname;
    try {
        while (1) {
            $tempname = sprintf('%s.%08x', $dest, int(rand(0xffffffff)));
            if (symlink($target, $tempname)) {
                last;
            } elsif (!$!{EEXIST}) {
                throw Oops("$tempname: symlink: $!");
            }
        }

        system('chown', '-h', "$options{uid}:$options{gid}", $tempname);
        if ($? == -1) {
            throw Oops("chown -h: exec: $!");
        } elsif ($? & 127) {
            throw Oops("chown -h $options{uid}:$options{gid} $tempname: killed by signal " . ($? & 127));
        } elsif ($? >> 8) {
            throw Oops("chown -h $options{uid}:$options{gid} $tempname: exited with nonzero status " . ($? >> 8));
        }

        rename($tempname, $dest) || throw Oops("$tempname: rename: $!");
    } finally {
        unlink($tempname);
    };

    return $target;
}

# read_perms DIRECTORY
# If there is in DIRECTORY a _perm file indicating ownership and permissions
# for files in that directory, read its contents and return them as a reference
# to a hash of FILENAME => [UID, GID, MODE]. Dies on error.
sub read_perms ($) {
    my $indir = shift;
    $indir =~ s#(?<!^)/$##;
    my $f = new IO::File("$indir/_perm");
    my $h = { };
    try {
        if (!$f) {
            if ($!{ENOENT}) {
                return { };
            } else {
                throw Oops("$indir/_perm: $!");
            }
        }

        verbose("READPERMS $indir/_perm\n");

        my $n = 0;
        while (defined(my $line = $f->getline())) {
            ++$n;
            chomp($line);
            # Skip lines which are blank or begin #.
            next if ($line =~ /^#/ || $line =~ /^\s*$/);

            $line =~ s/^\s+//;
            $line =~ s/\s+$//;

            my ($name, $owner, $mode) = split(/\s+/, $line);

            my ($uid, $gid, $perm);

            # Ownership.
            if ($owner =~ /([^:]+):([^:]+)/) {
                ($uid, $gid) = ($1, $2);
                if ($uid !~ /^(0|[1-9][0-9]*)$/) {
                    $uid = getpwnam($uid)
                        || throw Oops("$indir/_perm:$n: '$1' is not a valid UID or username");
                }
                if ($gid !~ /^(0|[1-9][0-9]*)$/) {
                    $gid = getgrnam($gid)
                        || throw Oops("$indir/_perm:$n: '$2' is not a valid GID or groupname");
                }
            } elsif ($owner ne '-') {
                throw Oops("$indir/_perm:$n: '$owner' is not a valid owner string (should be U:G)");
            }

            # Permissions.
            if ($mode eq '-') {
                ;
            } elsif ($mode =~ /^0?[0-7]+$/) {
                $perm = oct($mode);
            } elsif (!defined($perm = mySociety::Util::symbolic_permissions(0, $mode))) {
                throw Oops("$indir/_perm:$n: '$mode' is neither a valid octal nor a symbolic mode");
            }

            $uid = $default_uid if (!defined($uid));
            $gid = $default_gid if (!defined($uid));
            if (!defined($perm)) {
                my $st = stat("$indir/$name");
                if ($st) {
                    $perm = $st->mode() & 07777;
                } else {
                    $perm = $default_file_mode;
                }
            }

            $h->{$name} = [$uid, $gid, $perm];
        }

        throw Oops("$indir/_perm:$n: $!") if ($f->error());
    } finally {
        $f->close() if (defined($f));
    };

    return $h;
}

# process_directory INDIR OUTDIR SETTINGS
# Process the contents of INDIR (configuration file templates under version
# control), writing it into OUTDIR, and using the given SETTINGS file (which is
# passed by the -p option to mugly). Operates recursively, processing files
# before subdirectories. Dies on error.
sub process_directory ($$$);
sub process_directory ($$$) {
    my ($indir, $outdir, $settings) = @_;
    $indir =~ s#(?<!^)/$##;
    $outdir =~ s#(?<!^)/$##;

    verbose("PROCESS $indir\n");
    my $perm = read_perms($indir);

    my %havefile;
    my @subdirs = ( );
    opendir(D, $indir) or die "$indir: opendir: $!";
    while (defined(my $name = readdir(D))) {
        # XXX should have an exclusion list (maybe use .cvsignore?)
        next if ($name eq '_perm' || $name eq '.' || $name eq '..' || $name eq 'CVS');
        throw Oops("$indir/$name: already created $name, from $havefile{$name}")
            if (exists($havefile{$name}));
        my $s = lstat("$indir/$name");
        my $mode = $s->mode() & 07777;
        my $is_symlink = 0;
        if (S_ISDIR($s->mode())) {
            # This is a directory. Create it in the output, and add it to the
            # list of subdirectories into which to recurse.
            my $m = exists($perm->{$name}) ? $perm->{$name} : $mode;
            verbose("DIRECTORY $indir/$name\n");
            mkdir("$outdir/$name", $m) or throw Oops("$outdir/$name: mkdir: $!");
            $havefile{$name} = $name;
            push(@subdirs, $name);
        } elsif (S_ISREG($s->mode())) {
            if ($name =~ /.\.symlink$/) {
                # File specifies a symlink which should be created.
                my $f = new IO::File("$indir/$name")
                    or throw Oops("$indir/$name: open: $!");
                my $target = join('', $f->getlines());
                throw Oops("$indir/$name: read: $!") if ($f->error());
                $f->close();
                $name =~ s/\.symlink$//;
                throw Oops("$indir/$name: already created $name, from $havefile{$name}")
                    if (exists($havefile{$name}));
                $target =~ s#\n$##s;
                throw Oops("$indir/$name.symlink: symlink file syntax is 'To: TARGET\\n'") if ($target !~ /^To:/);
                $target =~ s#^To:\s*##;
                throw Oops("$indir/$name.symlink: specified symlink target contains illegal characters") if ($target =~ /[\0\n]/);
                print STDERR "$indir/$name.symlink: warning: symlink target is absolute\n" if ($target =~ m#^/#);
                verbose("SYMLINK $indir/$name\n");
                symlink($target, "$outdir/$name") or throw Oops("$outdir/$name: symlink: $!");
                $havefile{$name} = "$name.symlink";
                $is_symlink = 1;
            } elsif ($name =~ /.\.ugly$/) {
                # File specifies macro source.
                $name =~ s/\.ugly$//;
                throw Oops("$indir/$name: already created $name, from $havefile{$name}")
                    if (exists($havefile{$name}));
                verbose("MUGLY $indir/$name\n");
                system($mugly_bin, '-O', "$outdir/$name", "-p", $settings, "$indir/$name.ugly");
                if ($? == -1) {
                    throw Oops("$mugly_bin: exec: $!");
                } elsif ($? & 127) {
                    throw Oops("$mugly_bin ... $indir/$name.ugly: killed by signal " . ($? & 127));
                } elsif ($? >> 8) {
                    throw Oops("$mugly_bin ... $indir/$name.ugly: exited with nonzero status " . ($? >> 8));
                }
                $havefile{$name} = "$name.ugly";
            } else {
                verbose("COPY $indir/$name\n");
                install_file("$indir/$name", "$outdir/$name", undef,
                              mode => exists($perm->{$name}) ? $perm->{$name} : $mode);
                $havefile{$name} = $name;
            }
        } else {
            throw Oops("$indir/$name: not a regular file or a directory");
        }

        my ($uid, $gid) = ($default_uid, $default_gid);
        if (exists($perm->{$name})) {
            ($uid, $gid) = @{$perm->{$name}};
            $mode = $perm->{$name}->[2];
        }
        if ($is_symlink) {
            # perl lacks lchown
            system('chown', '-h', "$uid:$gid", "$outdir/$name");
            if ($? == -1) {
                throw Oops("chown -h: exec: $!");
            } elsif ($? & 127) {
                throw Oops("chown -h $uid:$gid $outdir/$name: killed by signal " . ($? & 127));
            } elsif ($? >> 8) {
                throw Oops("chown -h $uid:$gid $outdir/$name: exited with nonzero status " . ($? >> 8));
            }
        } else {
            chown($uid, $gid, "$outdir/$name")
                or throw Oops("$outdir/$name: chown: $!");
            chmod($mode, "$outdir/$name")
                or throw Oops("$outdir/$name: chmod: $!");
        }
    } 
    closedir(D);

    foreach my $dir (@subdirs) {
        process_directory("$indir/$dir", "$outdir/$dir", $settings);
    }
}

# file_type MODE
# Return a description of the type of the file with the given MODE bits.
sub file_type ($) {
    my $m = shift;
    if (S_ISDIR($m)) {
        return "directory";
    } elsif (S_ISREG($m)) {
        return "regular file";
    } elsif (S_ISLNK($m)) {
        return "symbolic link";
    } elsif (S_ISFIFO($m)) {
        return "named pipe";
    } elsif (S_ISCHR($m)) {
        return "character device";
    } elsif (S_ISBLK($m)) {
        return "block device";
    }
}

# file_type_tar MODE
# Return the tar file type for a file with the given MODE bits.
sub file_type_tar ($) {
    my $m = shift;
    if (S_ISDIR($m)) {
        return Archive::Tar::Constant::DIR;
    } elsif (S_ISREG($m)) {
        return Archive::Tar::Constant::FILE;
    } elsif (S_ISLNK($m)) {
        return Archive::Tar::Constant::SYMLINK;
    } elsif (S_ISFIFO($m)) {
        return Archive::Tar::Constant::FIFO;
    } elsif (S_ISCHR($m)) {
        return Archive::Tar::Constant::CHARDEV;
    } elsif (S_ISBLK($m)) {
        return Archive::Tar::Constant::BLOCKDEV;
    }
}

# install_files TAR INDIR [OUTDIR]
# Install files from INDIR (presumably, the OUTDIR previously passed to
# process_files) onto the real system to OUTDIR, or, if it is not specified, /.
# Record the files saved in TAR so that they can be compared against those on
# the real system later.
sub install_files ($$;$);
sub install_files ($$;$) {
    my ($tar, $indir, $outdir) = @_;
    $indir =~ s#(?<!^)/$##;
    $outdir ||= '/';

    verbose("INSTALL TO $outdir\n");

    my @subdirs = ( );
    opendir(D, $indir) or throw Oops("$indir: opendir: $!");
    while (defined(my $name = readdir(D))) {
        next if ($name eq '.' || $name eq '..');
        my $outname = $outdir eq '/' ? "$outdir$name" : "$outdir/$name";
        $outname = File::Spec->canonpath($outname);
        my $st = lstat("$indir/$name") || throw Oops("$indir/$name: lstat: $!");

        my %taropts = (
                uid => $st->uid(),
                uname => getpwuid($st->uid()),
                gid => $st->gid(),
                gname => getpwuid($st->gid()),
                mode => S_IMODE($st->mode()),
                type => file_type_tar($st->mode())
            );

        if (S_ISDIR($st->mode())) {
            my $st2 = lstat($outname);
            throw Oops("$outname: lstat: $!") if (!$st2 && !$!{ENOENT});
            throw Oops("$outname: already exists, but is a " . file_type($st2->mode()) . ", not a directory")
                if ($st2 && !S_ISDIR($st2->mode()));
            verbose("DIRECTORY $outname\n");
            if (!$st2) {
                mkdir($outname, $st->mode() & 07777)
                    || throw Oops("$outname: mkdir: $!");
            } else {
                chmod($st->mode() & 07777, $outname)
                    || throw Oops("$outname: chmod: $!");
            }
            chown($st->uid(), $st->gid(), $outname)
                || throw Oops("$outname: chown: $!");
            push(@subdirs, $name);
            $tar->add_data(".$outname", "", \%taropts);
        } elsif (S_ISREG($st->mode())) {
            my $filedata;
            verbose("FILE $outname\n");
            install_file("$indir/$name", $outname, \$filedata);
            $tar->add_data(".$outname", $filedata, \%taropts);
        } elsif (S_ISLNK($st->mode())) {
            verbose("SYMLINK $outname\n");
            $taropts{linkname} = install_symlink("$indir/$name", $outname);
            $tar->add_data(".$outname", "", \%taropts);
        } else {
            throw Oops("$indir/$name: not a regular file, directory or symlink");
        }
    }
    closedir(D);
    
    foreach my $dir (@subdirs) {
        my $outname = $outdir eq '/' ? "$outdir$dir" : "$outdir/$dir";
        install_files($tar, "$indir/$dir", $outname);
    }
}


# compare_installed_files H TAR DIR
# Compare the files installed on the machine (under DIR) with those archived in
# TAR. Discrepancies are reported to H, and the total number of discrepancies
# returned.
sub compare_installed_files ($$) {
    my ($h, $tar, $dir) = @_;
    my $n = 0;
    foreach my $f ($tar->list_files([qw(name size uid gid mode linkname)])) {
        my $st = lstat("$dir/$f->{name}");
        my @what;
        if (!$st) {
            if ($!{ENOENT}) {
                push(@what, "removed");
            } else {
                throw Oops("$dir/$f->{name}: lstat: $!");
            }
        } else {
            # Metadata.
            push(@what, sprintf('UID changed: was %d; now %d', $f->{uid}, $st->uid()))
                if ($st->uid() != $f->{uid});
            push(@what, sprintf('GID changed: was %d; now %d', $f->{gid}, $st->gid()))
                if ($st->uid() != $f->{gid});
            push(@what, sprintf('permissions changed: were %04o; now %04o', S_IMODE($f->{mode}), S_IMODE($st->mode())))
                if (S_IMODE($f->{mode}) != S_IMODE($st->mode()));
            push(@what, sprintf('file type changed: was %s; now %s', file_type($f->{mode}), file_type($st->mode())))
                if (S_IFMT($f->{mode}) != S_IFMT($st->mode()));
            if (S_ISLNK($f->{mode}) && S_ISLNK($st->mode())) {
                my $target = readlink("$dir/$f->{name}")
                                || throw Oops("$dir/$f->{name}: readlink: $!");
                push(@what, sprintf('target of symbolic link changed: was %s; now %s', $f->{linkname}, $target))
                    if ($f->{linkname} ne $target);
            } elsif (S_ISREG($f->{mode}) && S_ISREG($st->mode())) {
                # Compare the two files.
                my ($tmph, $tmpn) = mySociety::Util::named_tempfile();
                $tmph->print($tar->get_content($f->{name}))
                    || throw Oops("$tmpn: write: $!");
                $tmph->close();
                my $p = new IO::Pipe() || throw Oops("pipe: $!");
                $p->reader("diff", "-u", $tmpn, "$dir/$f->{name}");
                my @diff;
                while (defined(my $line = $p->getline())) {
                    chomp($line);
                    push(@diff, $line);
                }
                throw Oops("read from diff: $!") if ($p->error());
                wait();
                if ($? & 127) {
                    throw Oops("diff: died with signal " . ($? & 127));
                } elsif ($? >> 8) {
                    push(@what,
                        'contents of file changed; diff follows:',
                        '--- as last installed',
                        '+++ at present',
                        @diff[2 .. $#diff]);
                }
            }
        }

        if (@what) {
            $h->print("$f->{name}\n", map { "  $_\n" } @what);
        }
    }
}

my $retval = 0;
my $tempdir;
try {
    throw Oops("can't find executable mugly (tried $mugly_bin)") unless (-x $mugly_bin);
    throw Oops("must be run as root") if (getuid() != 0);

    throw Oops("two arguments must be template configuration tree and settings file") if (@ARGV != 2);
    my ($tree, $settings) = @ARGV;

    throw Oops("first argument must be a directory") if (!-d $tree);
    throw Oops("second argument must be a file") if (!-f $settings);

    $tempdir = mySociety::Util::tempdir();

    verbose("temporary directory is $tempdir\n");

    process_directory($tree, $tempdir, $settings);
    my $tar = new Archive::Tar();
    install_files($tar, $tempdir);
    $tar->write("test.tar") or throw Oops("test.tar: $!");
} catch Oops with {
    my $E = shift;
    print STDERR "deploy-configuration: ", $E->text(), "\n";
} finally {
    mySociety::Util::tempdir_cleanup($tempdir) if ($tempdir);
};
