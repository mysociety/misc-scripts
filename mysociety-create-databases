#!/usr/bin/perl -w
#
# mysociety-create-database:
# Creates databases that are listed in vhosts.pl. Creates corresponding users
# and gives them permissions and right password. Testharness databases/users
# get the extra ownership and permissions they need.
#
# Copyright (c) 2008 UK Citizens Online Democracy. All rights reserved.
# Email: francis@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: mysociety-create-databases,v 1.17 2012-07-20 13:59:16 ian Exp $';

package main;

use strict;
require 5.8.0;

use FindBin;
use lib "$FindBin::RealBin/../perllib";
my $mysociety_bin = $FindBin::RealBin;
my $servers_dir = "$FindBin::RealBin/../../servers";
my $mysociety_dir = "$FindBin::RealBin/../../mysociety";

use mySociety::SystemMisc qw(shell);
use mySociety::Config;
use mySociety::ServerClass;

use Data::Dumper;
use Sys::Hostname;
use IO::Socket::INET;
use DBI

our $verbose = $ENV{VERBOSE} ? 1 : 0;

#####################################################################
# General functions

sub pgpw {
    $_ = shift;
    $_ = `/data/mysociety/bin/pgpw $_`;
    s/\s+$//;
    return $_;
}

#####################################################################
# Main code

if (getpwuid($>) ne 'postgres' && getpwuid($>) ne 'root') {
    die "Please run as user root, script will be automatically run also as user postgres";
}

# Read in configuration file
our ($vhosts, $sites, $databases);
require "$servers_dir/vhosts.pl";

# Various other parameters
my $myhostname = hostname;

# Go through each database
my $database_configs;
foreach my $database (keys %{$databases}) {
    my $params = $databases->{$database};
    if ($params->{type} eq 'psql') {
        # Is it for our server? and we are right user?
        if ($params->{host} eq $myhostname && getpwuid($>) eq 'postgres') {

            my @out;

            # Testharness databases get dropped and recreated by the test script, so
            # give them more permissions.
            my $testharness = 0;
            if ($database =~ m/testharness$/) {
                $testharness = 1;
            }

            # Connect to server
            my $dbh = DBI->connect("dbi:Pg:dbname=template1;port=$params->{port}", 'postgres', undef, { PrintWarn => 1, PrintError => 1, RaiseError => 0, AutoCommit => 1 }) || die DBI->errstr();

            # Create user with same name as database
            if (!$dbh->selectrow_array("select count(*) from pg_catalog.pg_user where usename = '$database'")) {
                my $password = pgpw($database);
                push @out, "creating user";
                $dbh->do("create user \"$database\" with password '$password'");
            }

            # Create database
            if (!$dbh->selectrow_array("select count(*) from pg_catalog.pg_database where datname = '$database'")) {
                push @out, "creating db";
                my $owner_clause = "";
                if ($testharness) {
                    $owner_clause = "owner \"$database\"" 
                }
                my $template_clause = '';
		my $encoding = 'UTF8';
		if ($params->{encoding}) {
		    # template1 is UTF-8, so we have to use template0 for different encodings
		    $encoding = $params->{encoding} if $params->{encoding};
		    $template_clause = ' template "template0"';
		} elsif ($params->{geo}) {
                    $template_clause = ' template "template_postgis"' if $params->{geo};
		}
                $dbh->do("create database \"$database\" $owner_clause $template_clause encoding '$encoding'");
		if ($params->{encoding}) {
		    # As we're not using template1, we have to enable PL/pgSQL for the new database
		    my $dbh_db = DBI->connect("dbi:Pg:dbname=$database;port=$params->{port}", 'postgres', undef, { PrintWarn => 1, PrintError => 1, RaiseError => 0, AutoCommit => 1 }) || die DBI->errstr();
		    $dbh_db->do("CREATE FUNCTION plpgsql_call_handler() RETURNS OPAQUE AS '\$libdir/plpgsql' LANGUAGE 'C';");
		    $dbh_db->do("CREATE TRUSTED PROCEDURAL LANGUAGE 'plpgsql' HANDLER plpgsql_call_handler LANCOMPILER 'PL/pgSQL';");
		    $dbh_db->disconnect;
		}
            }

            # Give user permissions on database
            $dbh->do("grant all on database \"$database\" to \"$database\" ");
            if ($testharness) {
                $dbh->do("alter user \"$database\" with createdb");
            }

            push @out, "no change" if $::verbose && !@out;
            print "$database (psql", ($params->{port} == 5432 ? "" : " port $params->{port}"), "): ", join('; ', @out), "\n" if @out;

            $dbh->disconnect();
        }
    } elsif ($params->{type} eq 'mysql') {
        if ($params->{host} eq $myhostname && getpwuid($>) eq 'root') {
            print "mysql database '$database' on host $myhostname\n" if $::verbose;

            # get the root db password
            my $root_password = pgpw('root');
            # Connect to server
            my $dbh = DBI->connect("dbi:mysql:dbname=mysql", 'root', $root_password, { PrintWarn => 1, PrintError => 1, RaiseError => 0, AutoCommit => 1 }) || die DBI->errstr();

            # Create database
            $dbh->do("create database if not exists `$database`");

            # Create user with same name as database
            my $password = pgpw($database);
            $dbh->do("grant all on `$database`.* to `$database` identified by '$password'");
        }
    } else {
        die "unknown database type '$params->{type}'";
    }
}

# Create warm standby clusters, including configuration files
# XXX eventually the configs will be created dynamically with a post-config script,
#     but those don't exist yet.
if(getpwuid($>) eq 'root') {
    my $pguid=getpwnam('postgres');
    my $pggid=getgrnam('postgres');

    foreach my $machine (glob "$servers_dir/machines/*.pl") {
        our $database_failover_pair='';
	our ($hostnumber, $hostname, $domainname);
        do $machine;

	next if($database_failover_pair ne $myhostname);

	my %dbtypes;
	$dbtypes{'psql'}=0 if(mySociety::ServerClass::server_in_class($myhostname, "database-psql-standby"));
	$dbtypes{'mysql'}=0 if(mySociety::ServerClass::server_in_class($myhostname, "database-mysql-standby"));

        foreach my $db (values %$databases) {
	    $dbtypes{$db->{type}}++ if($db->{host} eq $hostname);
	}

        foreach my $dbtype (keys %dbtypes) {
            #next if(!$dbtypes{$dbtype});

            if($dbtype eq 'psql') {
	        # ensure a unique port for each standby instance...
	        my $port=5432 + $hostnumber;
	        my $clusterdir="/var/lib/postgresql/8.4/".$hostname."_standby";

                # ...but don't go any further if something's already running on that port,
                # or if the cluster dir already exists.
	        next if(-d $clusterdir);
                my $sock=IO::Socket::INET->new(PeerAddr=>'localhost', PeerPort=>"$port", PeerProto=>'tcp');
	        next if($sock);
	        die "connect test failed: $!" if($! ne 'Connection refused');

	        # create a new cluster, make a directory for incoming logs, and drop in 
	        # a recovery.conf file to make sure it comes up in recovery mode.
	        die "pg_createcluster failed for $hostname"
	            unless(system("pg_createcluster -p $port 8.4 ".$hostname."_standby") >> 8 == 0);
            
	        # make the directory that will receive logs from the live database...
	        mkdir "$clusterdir/incoming_logs";

	        # ...and drop in a recovery.conf so that the database will start in recovey mode
                open RECOVERY, ">$clusterdir/recovery.conf" or die "can't write to $clusterdir/recovery.conf: $!";
	        print RECOVERY "restore_command = '/usr/lib/postgresql/8.4/bin/pg_standby -t $clusterdir/fail_over_now $clusterdir/incoming_logs %f %p %r'\n";
	        close RECOVERY;

                # fix up permissions
	        chown $pguid, $pggid, "$clusterdir/incoming_logs", "$clusterdir/recovery.conf";
	        chmod 0700, "$clusterdir/incoming_logs";

	        print "warm standby cluster created for $hostname on port $port\n" if $::verbose;
                print "*** You must transfer the initial state of the live database on $hostname\n";
                print "*** before you can start the warm standby cluster ".$hostname."_cluster\n";

	    } elsif($dbtype eq 'mysql') {
	        # connect to the database and create a replication user if it doesn't already exist,
	        # and warn if it does exist but without the right permissions
	        my $repl_username=$hostname."_repl";
	        my $dbh = DBI->connect("dbi:mysql:database=mysql", 'root', pgpw('root'), { PrintWarn => 1, PrintError => 1, RaiseError => 0, AutoCommit => 1 }) || die DBI->errstr();
	        my $users = $dbh->selectall_arrayref("SELECT repl_slave_priv FROM user WHERE User='$repl_username'");
	        if(scalar(@$users)==1) {
	            warn "mysql user $repl_username exists but repl_slave_priv=$$users[0][0]" unless($$users[0][0] eq 'Y');
		    next;
	        } elsif(scalar(@$users)!=0) {
	            die "more than one row returned when 0 or 1 expected";
	        } else {
	            $dbh->do("CREATE USER '$repl_username'\@'$hostname.$domainname' IDENTIFIED BY '".pgpw($repl_username)."'");
                    $dbh->do("GRANT REPLICATION SLAVE ON *.* TO '$repl_username'\@'$hostname.$domainname'");
		}
	        $dbh->disconnect();
	        print "mysql replication user $repl_username created" if $::verbose;
            }
	}
    }
}

# Become user postgresql, and run script again to do postgresql ones
if (getpwuid($>) eq 'root') {
    # XXX yeuch, but seems easiest way to give postgres access to vhosts.pl, and postgres_secret
    chown((getpwnam("root"))[2], (getgrnam("postgres"))[2], "$servers_dir/vhosts.pl");
    chown((getpwnam("root"))[2], (getgrnam("postgres"))[2], "/etc/mysociety/postgres_secret");
    chmod(0755, '/data/mysociety/bin/pgpw');
    exit system("su postgres -c \"$0\"") >> 8;
}


