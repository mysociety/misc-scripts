#!/usr/bin/perl -w -I ../perllib/
#
# rabxresttopy.pl:
# Reads perldoc from a Perl class implementing a RABX interface, and produces a
# Python include file for talking to that RABX interface via REST/JSON.
#

my $rcsid = ''; $rcsid .= '$Id: rabxresttopy.pl,v 1.1 2009-02-24 14:49:41 francis Exp $';

use strict;

use Pod::POM;
use Data::Dumper;
use Pod::POM::View::Text;

use mySociety::StringUtils qw(trim);

my $perl_source = $ARGV[0];
die "Give source .pm file as first parameter" unless defined($perl_source);
my $main_include_path = $ARGV[1];
die "Give relative path to mysociety/phplib" unless defined($main_include_path);

my $parser = Pod::POM->new( { warn => 1} );
my $view = 'Pod::POM::View::Text';

# parse from a text string
my $pom = $parser->parse_file($perl_source) || die $parser->error();

# find items representing functions and display them
my ($rabx_namespace, $py_namespace, $conf_name);
sub process_functions {
    my $parent = shift;
    foreach my $content ($parent->content()) {
        # print STDERR $content->title() . "\n";
        if ($content->type() eq 'head2' or $content->type() eq 'over') {
            # Recurse through head2 or over
            process_functions($content)
        }  elsif ($content->type() eq 'item') {
            # Display function item as PHP.
            # Find parameters and function name
            my @params = split /\s+/, $content->title();
            my $function_name = shift @params;
            # Print the help comment
            my $comment = $view->view_item($content);
            $comment =~ s/$function_name/${py_namespace}_$function_name/g;
            chomp $comment;
            chomp $comment;
            $comment = trim($comment);
            # Create list of PHP variables with defaults for optional params
            my $optional = 0;
            my @opt_args;
            my @opt_args_no_default;
            my @call_args;
            do {
                my $param = $_;
                next if $param eq "..."; # func_get_args and PHP's flexible syntax covers this
                $optional = 1 if $param =~ m/\[/;
                my $without_punc = $param;
                $without_punc =~ s/[\[\]()]//g;
                push @opt_args, lc($without_punc) . ($optional ? " = None" : ""); 
                push @opt_args_no_default, lc($without_punc);
                push @call_args, lc($without_punc);
                $optional = 0 if $param =~ m/\]/;
            } foreach @params;
            my $opt_list = join(", ", @opt_args);
            my $opt_list_no_default = join(", ", @opt_args_no_default);
            my $call_list = join(", ", @call_args);
            # Print out PHP function
            print <<END;
def $function_name($opt_list):
    '''$comment
    '''
    result = do_call_rest_rabx('${rabx_namespace}.${function_name}', $opt_list_no_default)
    return result

END
        }
    }
}

sub process_constants {
    my $parent = shift;
    foreach my $content ($parent->content()) {
        if ($content->type() eq 'head2' or $content->type() eq 'over') {
            # Recurse through head2 or over
            process_constants($content)
        } elsif ($content->type() eq 'item') {
            my ($constant, $value) = split /\s+/, $content->title();
            my $comment = $view->view_item($content);
            $comment =~ s/\* $constant $value//gs;
            $comment =~ s/\n/ /g;
            $comment =~ s/\s$//gs;
            $comment =~ s/^\s//gs;
            print "$constant = $value        # $comment\n";
        }
    }
}


# find info
my $description;
foreach my $head1 ($pom->head1()) {
    if ($head1->title() eq "DESCRIPTION") {
        $description = trim($view->view_text($head1));
        $description =~ s/Implementation of/Client interface for/;
    }
    if ($head1->title() eq "NAME") {
        $rabx_namespace = trim($view->view_text($head1));
        if ($rabx_namespace eq 'FYR.Queue') {
            $py_namespace = 'msg';
            $conf_name = 'FYR_QUEUE';
        } else {
            $py_namespace = lc $rabx_namespace;
            $conf_name = uc $rabx_namespace;
        }
    }
}
die "Need DESCRIPTION section in perldoc" if !$description;
die "Need NAME section in perldoc" if !$rabx_namespace;

# Print header
print <<END;
# THIS FILE WAS AUTOMATICALLY GENERATED BY $0, DO NOT EDIT DIRECTLY
# 
# ${py_namespace}.py:
# $description
#
# Copyright (c) 2009 UK Citizens Online Democracy. All rights reserved.
# WWW: http://www.mysociety.org
#
# $rcsid
#

import mysociety.config
import mysociety.rabx

def do_call_rest_rabx(*params):
    base_url = mysociety.config.get("${conf_name}_URL")
    return mysociety.rabx.call_rest_rabx(base_url, params)

END

# find the functions
foreach my $head1 ($pom->head1()) {
    if ($head1->title() eq "FUNCTIONS") {
        process_functions($head1);
    } elsif ($head1->title() eq "CONSTANTS") {
        process_constants($head1);
        print "\n";
    }
}

# print footer
print <<END;
END

