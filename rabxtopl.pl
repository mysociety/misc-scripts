#!/usr/bin/perl -w -I ../perllib/
#
# rabxtopl.pl:
# Reads perldoc from a Perl class implementing a RABX interface, and produces a
# perl module file for talking to that RABX interface.
#

my $rcsid = ''; $rcsid .= '$Id: rabxtopl.pl,v 1.1 2005-11-25 16:27:12 francis Exp $';

use strict;

use Pod::POM;
use Data::Dumper;
use Pod::POM::View::Text;

use mySociety::StringUtils qw(trim);

my $perl_source = $ARGV[0];
die "Give source .pm file as first parameter" unless defined($perl_source);
my $main_include_path = $ARGV[1];
die "Give relative path to mysociety/perllib/mySociety" unless defined($main_include_path);

my $parser = Pod::POM->new( { warn => 1} );
my $view = 'Pod::POM::View::Text';

# parse from a text string
my $pom = $parser->parse_file($perl_source) || die $parser->error();

# find items representing functions and display them
my ($rabx_namespace, $pl_module, $conf_name);
sub process_functions {
    my $parent = shift;
    foreach my $content ($parent->content()) {
        if ($content->type() eq 'head2' or $content->type() eq 'over') {
            # Recurse through head2 or over
            process_functions($content)
        }  elsif ($content->type() eq 'item') {
            # Display function item as Perl.
            # Find parameters and function name
            my @params = split /\s+/, $content->title();
            my $function_name = shift @params;
            # Print the help comment
            my $comment = $view->view_item($content);
            $comment =~ s/\*/=item/;
            $comment =~ s/$function_name/${pl_module}::$function_name/g;
            chomp $comment;
            chomp $comment;
            print "$comment\n\n";
            print "=cut\n";
            # Create list of PHP variables with defaults for optional params
            my $optional = 0;
            my $compulsory_part = "";
            my $optional_part = "";
            do {
                my $param = $_;
                next if $param eq "..."; # func_get_args and PHPs flexible syntax covers this
                $optional = 1 if $param =~ m/\[/;
                $optional_part .= "\$" if ($optional);
                $compulsory_part .= "\$" if (!$optional);
                $optional = 0 if $param =~ m/\]/;
            } foreach @params;
            $optional_part = ";$optional_part" if ($optional_part);
            # Print out Perl function
            print <<END;
sub $function_name ($compulsory_part$optional_part) {
    configure() if !defined \$rabx_client;
    return \$rabx_client->call('${rabx_namespace}.${function_name}', \@_);
}

END
        }
    }
}

sub process_constants {
    my $parent = shift;
    foreach my $content ($parent->content()) {
        if ($content->type() eq 'head2' or $content->type() eq 'over') {
            # Recurse through head2 or over
            process_constants($content)
        } elsif ($content->type() eq 'item') {
            my ($constant, $value) = split /\s+/, $content->title();
            my $comment = $view->view_item($content);
            $comment =~ s/\*/=item/;
            print $comment;
            print "=cut\n";
            print "use constant $constant => $value;\n\n";
        }
    }
}

# find info
my $description;
foreach my $head1 ($pom->head1()) {
    if ($head1->title() eq "DESCRIPTION") {
        $description = trim($view->view_text($head1));
        $description =~ s/Implementation of/Client interface for/;
    }
    if ($head1->title() eq "NAME") {
        $rabx_namespace = trim($view->view_text($head1));
        if ($rabx_namespace eq 'FYR.Queue') {
            $pl_module = 'FYRQueue';
            $conf_name = 'FYR_QUEUE';
        } else {
            $pl_module = $rabx_namespace;
            $conf_name = uc $rabx_namespace;
        }
    }
}
die "Need DESCRIPTION section in perldoc" if !$description;
die "Need NAME section in perldoc" if !$rabx_namespace;

# Print header
print <<END;
#!/usr/bin/perl
# 
# THIS FILE WAS AUTOMATICALLY GENERATED BY $0, DO NOT EDIT DIRECTLY
# 
# ${pl_module}.pm:
# $description
#
# Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
# WWW: http://www.mysociety.org
#
# $rcsid

package mySociety::${pl_module};

use strict;

use RABX;
use mySociety::Config;

=item configure [URL]

Set the RABX URL which will be used to call the functions. If you don't
specify the URL, mySociety configuration variable ${conf_name}_URL will be used
instead.

=cut
my \$rabx_client = undef;
sub configure (;\$) {
    my (\$url) = \@_;
    \$url = mySociety::Config::get('${conf_name}_URL') if !defined(\$url);
    \$rabx_client = new RABX::Client(\$url) or die qq(Bad RABX proxy URL "\$url");
}

END

# find the functions
foreach my $head1 ($pom->head1()) {
    if ($head1->title() eq "FUNCTIONS") {
        process_functions($head1);
    } elsif ($head1->title() eq "CONSTANTS") {
        process_constants($head1);
    }
}

# print footer
print <<END;

1;
END

