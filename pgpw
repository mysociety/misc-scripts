#!/usr/bin/perl -w
#
# pgpw:
# Construct the Postgres password for a given user.
#
# The idea here is that passwords are computed from hash(secret, username).
# This means that we don't have to manage passwords explicitly, but can still
# give out limited access to people safely and don't have to rely on identd
# between multiple machines.
# 
# Use "create user 'foo' with password '...';" within psql to actually make the
# user with the password generated by this script.
#
# Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: pgpw,v 1.4 2010-01-27 17:20:58 francis Exp $';

use strict;

use Digest::SHA1;
use Errno;
use IO::File;

my $secret = undef;

sub pgpw ($) {
    my $user = shift;
    return substr(Digest::SHA1::sha1_base64("$secret$user"), 0, 8);
}

foreach my $file ($ENV{PGSECRET}, '/etc/mysociety/postgres_secret', '/usr/local/etc/mysociety/postgres_secret') {
    next if (!defined($file));
    my $h = new IO::File($file, O_RDONLY);
    if (!$h) {
        if ($!{ENOENT}) {
            next;
        } else {
            print STDERR "pgpw: opening $file as euid $>: $!\n";
            exit(1);
        }
    }
    $secret = join('', $h->getlines());
    if ($h->error()) {
        print STDERR "pgpw: reading $file as euid $>: $!\n";
        exit(1);
    }
    $h->close();
}

if (!defined($secret)) {
    print STDERR "pgpw: no secret file found e.g. /etc/mysociety/postgres_secret\n";
    exit(1);
}

if (@ARGV == 1) {
    print pgpw($ARGV[0]), "\n";
} else {
    foreach (@ARGV) {
        print "$_: ", pgpw($ARGV[0]), "\n";
    }
}

exit(0);
